<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>testsc 동적 시험 도움 라이브러리</title>
<!-- 2017-06-02 금 21:40 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">testsc 동적 시험 도움 라이브러리</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. testsc - 동적 시험 라이브러리</a>
<ul>
<li><a href="#sec-1-1">1.1. 무엇을 하는 라이브러리 인가 ?</a></li>
<li><a href="#sec-1-2">1.2. 장점</a></li>
<li><a href="#sec-1-3">1.3. 단점</a></li>
<li><a href="#sec-1-4">1.4. 참조</a></li>
</ul>
</li>
<li><a href="#sec-2">2. 사용방법</a>
<ul>
<li><a href="#sec-2-1">2.1. 테스트 스크립트 호출 부분 작성</a></li>
<li><a href="#sec-2-2">2.2. 테스트 스크립트 작성</a></li>
<li><a href="#sec-2-3">2.3. testsc 확장 모듈</a></li>
<li><a href="#sec-2-4">2.4. 개선 방법</a></li>
</ul>
</li>
<li><a href="#sec-3">3. 사용 시나리오</a>
<ul>
<li><a href="#sec-3-1">3.1. Codescroll 테스트케이스 생성</a></li>
<li><a href="#sec-3-2">3.2. Codescroll 에서 테스트스크립트(scheme 파일) 호출 부분 작성</a></li>
<li><a href="#sec-3-3">3.3. 테스트스크립트 작성</a></li>
<li><a href="#sec-3-4">3.4. 테스트스크립트 디버깅</a></li>
</ul>
</li>
<li><a href="#sec-4">4. reference</a>
<ul>
<li><a href="#sec-4-1">4.1. C API - </a></li>
<li><a href="#sec-4-2">4.2. scheme API - </a></li>
<li><a href="#sec-4-3">4.3. 추가 구현</a></li>
</ul>
</li>
<li><a href="#sec-5">5. scheme 문법 </a></li>
<li><a href="#sec-6">6. 용어</a>
<ul>
<li><a href="#sec-6-1">6.1. 테스트케이스</a></li>
<li><a href="#sec-6-2">6.2. 테스트스크립트</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> testsc - 동적 시험 라이브러리</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 무엇을 하는 라이브러리 인가 ?</h3>
<div class="outline-text-3" id="text-1-1">
<p>
동적 시험시 필요한 테스트데이터를 파일로 부터 읽어 오는 라이브러리이다.
파일의 형식은 scheme 스트립트이다. 간단한 데이터의 정의 뿐만 아니라
프로그래밍을 통한 데이터의 생성이 가능한다.  
</p>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 장점</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> 테스트 데이터 생성</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
CodeScroll가 함수 입력값에 대한 테스트데이터를 생성하기는 한다. 각
파라미터에 대하여 각각 테스트 데이터를 생성해 주는 것으로 보이며 변수들의
상관관계를 고려하여 만드는 것은 아닌 것 같다. 가령 함수의 인자로 3개의 enum
타입을 사용하는 경우 입력 가능한 모든 조합의 생성이 가능함에도 불구하고
사용자가 수동으로 입력하고 있는 실정이다. testsc 를 사용하며 각 입력값이
가지는 범위를 이용하여 다수의 파라미터에 대한 조합을 생성할 수 있다.  
</p>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> 다수의 테스트케이스 생성</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
테스트 데이터가 많을 경우 CodeScroll 이 제공하는 UI 를 통하여 데이터를
입력하기가 불편하다. 프로그래밍을 통하여 다수의 데이터도 간편하게 생성이
가능한다.  
</p>
</div>
</div>
<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> 테스트 데이터 재활용</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
Codescroll 에서 같은 scheme 파일을 읽어 오도록 설정하면 테스트 데이터를
재활용할 수 있다. 
구조가 같은 함수가 다수 있을 때 사용하면 편리하다. 
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 단점</h3>
<div class="outline-text-3" id="text-1-3">
<p>
scheme 언어에 대하여 지식이 있어야 사용 가능하다. 
</p>

<p>
<a href="#scheme_syntax">scheme 문법 참조</a>
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> 참조</h3>
<div class="outline-text-3" id="text-1-4">
</div><div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> C 함수 <a href="#testsc_c_api">4.1</a></h4>
</div>
<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><span class="section-number-4">1.4.2</span> scheme <a id="testsc_scheme_api" name="testsc_scheme_api"></a></h4>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 사용방법</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 테스트 스크립트 호출 부분 작성</h3>
<div class="outline-text-3" id="text-2-1">
<p>
관련 함수 상세 내용은 
</p>
</div>
<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> 테스트 케이스에서 관련 스크립트 지정</h4>
</div>
<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> 테스트 케이스에서 관련 값을 가져 오는 부분 지정</h4>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 테스트 스크립트 작성</h3>
<div class="outline-text-3" id="text-2-2">
<p>
앞서 지정한 폴더에 scheme 파일을 작성한다. <a href="#testsc_scheme_api">1.4.2</a>
테스트 스크립트에는 테스트번호 값을 이용하여 테스트별 스크립트 작성이
가능한다. 
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> testsc 확장 모듈</h3>
<div class="outline-text-3" id="text-2-3">
<p>
C 를 이용하여 확장 할 수 있다. 
</p>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> 개선 방법</h3>
<div class="outline-text-3" id="text-2-4">
</div><div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1"><span class="section-number-4">2.4.1</span> 일괄 빌드 수행</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
모든 테스트 케이스를 한꺼번에 컴파일 한 후 작업하면 더 효율 적으로 할 수
있다.
</p>
</div>
</div>
<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2"><span class="section-number-4">2.4.2</span> 테스트 데이터를 파일에서 가져오게 한다.</h4>
<div class="outline-text-4" id="text-2-4-2">
</div><ol class="org-ol"><li><a id="sec-2-4-2-1" name="sec-2-4-2-1"></a>컴파일 없이 테스트 수행을 할 수 있다.<br  /></li></ol>
</div>
<div id="outline-container-sec-2-4-3" class="outline-4">
<h4 id="sec-2-4-3"><span class="section-number-4">2.4.3</span> 테스트 데이터를 프로그래밍 할 수 있게 한다.</h4>
<div class="outline-text-4" id="text-2-4-3">
<p>
테스트 데이터에 대한 프로그래밍을 통하여 커버리지를 높일 수 있는 데이터를
생성할 수 있다.
</p>
</div>
</div>
<div id="outline-container-sec-2-4-4" class="outline-4">
<h4 id="sec-2-4-4"><span class="section-number-4">2.4.4</span> 라이브러리를 활용한다.</h4>
<div class="outline-text-4" id="text-2-4-4">
<p>
STUB 을 중복적으로 생성할 필요 없이 재사용 할 수 있다. 
</p>
</div>
<ol class="org-ol"><li><a id="sec-2-4-4-1" name="sec-2-4-4-1"></a>embedded language 활용<br  /><ol class="org-ol"><li><a id="sec-2-4-4-1-1" name="sec-2-4-4-1-1"></a>scheme<br  /><div class="outline-text-6" id="text-2-4-4-1-1">
<p>
문법이 간단하여 구현이 용이함. 
</p>
</div>
<ol class="org-ol"><li><a id="sec-2-4-4-1-1-1" name="sec-2-4-4-1-1-1"></a>구현 - tinyscheme<br  /><div class="outline-text-7" id="text-2-4-4-1-1-1">
<p>
5천 라인 정도의 C 파일로 language 가 구현 되어 있음. 
codescroll에서 사용하는 컴파일러만으로 컴파일 가능. 추가 도구 등이 필요
없음. 
</p>
</div>
</li></ol>
</li></ol>
</li></ol>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 사용 시나리오</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Codescroll 테스트케이스 생성</h3>
<div class="outline-text-3" id="text-3-1">
</div><div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1"><span class="section-number-4">3.1.1</span> 메뉴얼을 참고하여 테스트케이스를 생성한다.</h4>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Codescroll 에서 테스트스크립트(scheme 파일) 호출 부분 작성</h3>
<div class="outline-text-3" id="text-3-2">
<p>
다음에 나오는 함수의 상세 내용은 <a href="#testsc_c_api">4.1</a> 을 참조한다. 
</p>
</div>
<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1"><span class="section-number-4">3.2.1</span> 관련 헤더파일 include</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
<b>유닛테스트</b> 더블클릭 &gt;&gt;  <b>테스트 정보</b> &gt;&gt; <b>테스트 전역 코드</b>
</p>


<div class="figure">
<p><img src="file://u:/orgdir/testsc/testglobalcode.png" alt="testglobalcode.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2"><span class="section-number-4">3.2.2</span> 사용자 코드 작성</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
<b>유닛테스트</b> 더블클릭 &gt;&gt;  <b>테스트 정보</b> &gt;&gt; <b>사용자 코드</b>
</p>

<p>
테스트스크립트를 로딩하는 부분으로써 다음과 같이 호출한다. 
</p>

<p>
각 함수의 상세 내용은 <a href="#testsc_c_api">4.1</a> 을 참조한다. 
</p>

<div class="org-src-container">

<pre class="src src-cpp">testsc_init(CS_TESTCASENO(), "(testsc-require mb/t-0)", "c:/testsc/");
testsc_eval( "(testsc-require mb/t-9)") ;
</pre>
</div>

<p>
<a href="#testsc_init">4.1.8</a> 를 호출하여 testsc 를 초기화 한다. 마지막 파라미터의 경로는
testsc 의 HOME 경로가 된다. 그 경로아래에 불러올 스크립트가 있어야 한다. 
</p>


<p>
<a href="#testsc-require">4.2.1.2.1</a> 는 스크립트를 실행한다. 파라미터는 불러오고자 하는
스크립트명이다. (testsc-require mb/t-9) 은 testsc 홈폴더 아래의 mb/t-9.scm
파일을 호출한다. 
</p>

<p>
스크립트파일의 확장자(.scm)는 생략하여야만 한다. 
</p>

<p>
경로명은 다음과 같는 convention 으로 작성한다. .scm 파일은 t- 으로 시작하는
것을 convention 으로 한다. 
</p>

<ul class="org-ul">
<li>폴더명 : 테스트하고자 하는 .cpp 파일을 나타내는 약어
</li>
<li>t-0.scm : 테스트하고자 하는 .cpp 파일에서 공통으로 사용하는 상수(enum
타입 포함) 정의 
</li>
<li>t-testname.scm : 테스트케이스(함수별) 를 나타내는 약어. 
</li>
</ul>



<div class="figure">
<p><img src="file://u:/orgdir/testsc/usercode.png" alt="usercode.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3"><span class="section-number-4">3.2.3</span> 호출전 코드 작성</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
<b>유닛테스트</b> 더블클릭 &gt;&gt;  <b>테스트 정보</b> &gt;&gt; <b>테스트 대상 함수</b> &gt;&gt; <b>호출 전 코드</b>
</p>

<p>
테스트스크립트에서 읽은 값을 codescroll 변수에 설정한다. 
</p>

<div class="org-src-container">

<pre class="src src-cpp">iValue1    = testsc_ivalue("value1") ; 
dValue2    = testsc_dvalue("value2") ; 
strValue3  = testsc_strvalue("value3") ;
pValue4    = (track_t*)testsc_admin_get(0) ;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 테스트스크립트 작성</h3>
<div class="outline-text-3" id="text-3-3">
</div><div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1"><span class="section-number-4">3.3.1</span> 변수 값 선언</h4>
<div class="outline-text-4" id="text-3-3-1">
<div class="org-src-container">

<pre class="src src-scheme">(define value1 10)
(define value2 3.1415926378)
(define value3 "string 테스트 데이터")
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 테스트스크립트 디버깅</h3>
<div class="outline-text-3" id="text-3-4">
<p>
값이 예상과 다르거나 스크립트 로딩에 오류가 있는 것 같을 때 수행 
</p>
</div>
<div id="outline-container-sec-3-4-1" class="outline-4">
<h4 id="sec-3-4-1"><span class="section-number-4">3.4.1</span> scheme 실행</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
tinyscheme 홈 플더의 scheme.exe 를 실행한다. 
<a href="#testsc-set-testnum">4.2.1.3.1</a> 를 이용하여 디버깅 하고자 하는 테스트 번호를 설정한다. 
(testsc-require ac/t-1 ) 를 이용하여 테스트 스크립트를 로딩한다. 
</p>

<p>
확인하고자 하는 값을 입력하면 값이 출력됨 
</p>
<div class="org-src-container">

<pre class="src src-scheme">(testsc-set-testnum 8 )
(testsc-require ac/t-1 )
ts&gt; mas
100
ts&gt; testsc
1
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> reference</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> C API - <a id="testsc_c_api" name="testsc_c_api"></a></h3>
<div class="outline-text-3" id="text-4-1">
</div><div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> long testsc_ivalue(const char* name)  <a id="testsc_ivalue" name="testsc_ivalue"></a></h4>
<div class="outline-text-4" id="text-4-1-1">
<pre class="example">
</pre>
</div>
</div>
<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2"><span class="section-number-4">4.1.2</span> double testsc_dvalue(const char* name)  <a id="testsc_dvalue" name="testsc_dvalue"></a></h4>
</div>
<div id="outline-container-sec-4-1-3" class="outline-4">
<h4 id="sec-4-1-3"><span class="section-number-4">4.1.3</span> char* testsc_strvalue(const char* name)  <a id="testsc_strvalue" name="testsc_strvalue"></a></h4>
</div>
<div id="outline-container-sec-4-1-4" class="outline-4">
<h4 id="sec-4-1-4"><span class="section-number-4">4.1.4</span> int testsc_admin_length( void ) <a id="testsc_admin_length" name="testsc_admin_length"></a></h4>
</div>
<div id="outline-container-sec-4-1-5" class="outline-4">
<h4 id="sec-4-1-5"><span class="section-number-4">4.1.5</span> void testsc_admin_erase(int index ) <a id="testsc_admin_erase" name="testsc_admin_erase"></a></h4>
</div>
<div id="outline-container-sec-4-1-6" class="outline-4">
<h4 id="sec-4-1-6"><span class="section-number-4">4.1.6</span> void testsc_track_set(uint32_t id , network_track_data_ptr t ) <a id="testsc_track_set" name="testsc_track_set"></a></h4>
</div>
<div id="outline-container-sec-4-1-7" class="outline-4">
<h4 id="sec-4-1-7"><span class="section-number-4">4.1.7</span> void testsc_eval(const char *cmd)  <a id="testsc_eval" name="testsc_eval"></a></h4>
</div>
<div id="outline-container-sec-4-1-8" class="outline-4">
<h4 id="sec-4-1-8"><span class="section-number-4">4.1.8</span> void testsc_init(int testnum, const char *cmd, const char *homepath = 0 )  <a id="testsc_init" name="testsc_init"></a></h4>
</div>
<div id="outline-container-sec-4-1-9" class="outline-4">
<h4 id="sec-4-1-9"><span class="section-number-4">4.1.9</span> char* testsc_admin_get( int i )  <a id="testsc_admin_get" name="testsc_admin_get"></a></h4>
</div>
<div id="outline-container-sec-4-1-10" class="outline-4">
<h4 id="sec-4-1-10"><span class="section-number-4">4.1.10</span> void testsc_debug(const char*format &#x2026;)  <a id="testsc_debug" name="testsc_debug"></a></h4>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> scheme API - <a href="#testsc_scheme_api">1.4.2</a></h3>
<div class="outline-text-3" id="text-4-2">
</div><div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1"><span class="section-number-4">4.2.1</span> util.scm</h4>
<div class="outline-text-4" id="text-4-2-1">
</div><ol class="org-ol"><li><a id="sec-4-2-1-1" name="sec-4-2-1-1"></a>변수<br  /><ol class="org-ol"><li><a id="sec-4-2-1-1-1" name="sec-4-2-1-1-1"></a><b>testsc-home</b>  <a id="testsc-home" name="testsc-home"></a><br  /><div class="outline-text-6" id="text-4-2-1-1-1">
<ul class="org-ul">
<li>목적 : 스크립트 파일 위치 
</li>
<li>방향 : 
</li>
<li>사용법 
testsc-debug 를 이용하여 경로를 확인한다. 

<div class="org-src-container">

<pre class="src src-scheme">(testsc-debug *testsc-home*)
</pre>
</div>
</li>
</ul>
</div>
</li></ol>
</li>

<li><a id="sec-4-2-1-2" name="sec-4-2-1-2"></a>함수<br  /><ol class="org-ol"><li><a id="sec-4-2-1-2-1" name="sec-4-2-1-2-1"></a>(define-macro (testsc-require x) &#x2026;) <a id="testsc-require" name="testsc-require"></a><br  /></li>
<li><a id="sec-4-2-1-2-2" name="sec-4-2-1-2-2"></a>(define (t-offset start) &#x2026;) <a id="t-offset" name="t-offset"></a><br  /><div class="outline-text-6" id="text-4-2-1-2-2">
<p>
(define (t-offset start) (- (testsc-get-testnum) start))
</p>
</div>
</li>

<li><a id="sec-4-2-1-2-3" name="sec-4-2-1-2-3"></a>(define (for-each-index-offset offset proc  . args ) &#x2026;) <a id="for-each-index-offset" name="for-each-index-offset"></a><br  /><div class="outline-text-6" id="text-4-2-1-2-3">
<ul class="org-ul">
<li>목적 : 테스트케이스별 값을 설정한다. 
</li>
<li>사용법 : 테이스케이스별로 순차적으로 값을 설정하고자 할 때 사용한다. 
<div class="org-src-container">

<pre class="src src-scheme">(define testsc 0 )
(define order 0 )
(for-each-index-offset
  1
  (lambda (x)
    (set! testsc 1 )
    (set! order x)
    )
    system_types-assume_cntrl
    system_types-control_and_engage
    system_types-return_to_base
    system_types-transfer_cntrl
    system_types-launch_heli
    system_types-request_cntrl
    system_types-cancel_handover  
    -1
  )
</pre>
</div>
</li>
<li>입력 파라미터 
<ul class="org-ul">
<li>offset : 값 설정을 시작할 테스트케이스 번호
</li>
<li>proc   : 값 설정을 수행할 함수 
</li>
<li>args   : 테스트 값 
</li>
</ul>
</li>
</ul>
</div>
</li>

<li><a id="sec-4-2-1-2-4" name="sec-4-2-1-2-4"></a>(define ( feio offset proc args ) &#x2026;) <a id="feio" name="feio"></a><br  /><div class="outline-text-6" id="text-4-2-1-2-4">
<ul class="org-ul">
<li>목적 : 테스트케이스별 값을 설정한다. 
</li>
<li>사용법 : 테이스케이스별로 순차적으로 값을 설정하고자 할 때 사용한다. 
<a href="#for-each-index-offset">4.2.1.2.3</a> 와 비교하여 args 부분에 리스트가 올 수
있다. 
<div class="org-src-container">

<pre class="src src-scheme">(define i_enStatus 0)
(define m_bEnableCallback 0)
(define i_pchData_0 0)
(define i_pchData_1 0)

(feio
 1
 (lambda (x)
   (set! i_enStatus        (nth 0 x))
   (set! m_bEnableCallback (nth 1 x))
   (set! i_pchData_0       (nth 2 x))
   (set! i_pchData_1       (nth 3 x)))

 (combi '(11 12) '(1) '(4 5 ) '(1 0 )))
</pre>
</div>
</li>
</ul>
</div>
</li>

<li><a id="sec-4-2-1-2-5" name="sec-4-2-1-2-5"></a>(define (combi . args)&#x2026;) <a id="combi" name="combi"></a><br  /><div class="outline-text-6" id="text-4-2-1-2-5">
<ul class="org-ul">
<li>목적 : 테스트 데이터 생성(combination)
</li>
<li>사용법 : 

<div class="org-src-container">

<pre class="src src-scheme">(combi '(a b ) '(1 2 ))
</pre>
</div>

<p>
#+RESULT :
'((a 1) (a 2) (b 1) (b 2))
</p>
</li>
</ul>
</div>
</li>
<li><a id="sec-4-2-1-2-6" name="sec-4-2-1-2-6"></a>(define (nth n l) &#x2026;)<br  /><div class="outline-text-6" id="text-4-2-1-2-6">
<ul class="org-ul">
<li>목적 : 리스트에서 n 번째 항목을 리턴한다. 
</li>
<li>사용법 : 리스트에서 값을 가져오고자 할 때 사용한다. 

<div class="org-src-container">

<pre class="src src-scheme">(nth 3 '(zero one two three four))
</pre>
</div>

<p>
#+RESULT :
three
</p>
</li>

<li>입력 파라미터 
<ul class="org-ul">
<li>n : 리스트에서 가져오고자 하는 인덱스( 0 부터 시작 ) 
</li>
<li>l : 리스트 
</li>
</ul>
</li>
</ul>
</div>
</li>
<li><a id="sec-4-2-1-2-7" name="sec-4-2-1-2-7"></a>(define (num-list start end  ) &#x2026;) <a id="num-list" name="num-list"></a><br  /><div class="outline-text-6" id="text-4-2-1-2-7">
<ul class="org-ul">
<li>프로토타입 : (define (num-list start end  ) &#x2026;)
</li>
<li>목적 : 숫자 리스트를 리턴한다. 
</li>
<li>사용법 : 

<div class="org-src-container">

<pre class="src src-scheme">(num-list 1 10)
</pre>
</div>

<p>
#+RESULT :
'(1 2 3 4 5 6 7 8 9 )
</p>
</li>

<li>입력 파라미터 
<ul class="org-ul">
<li>start : 시작 값(포함)
</li>
<li>end : 종료 값(불포함)
</li>
</ul>
</li>
</ul>
</div>
</li></ol>
</li>


<li><a id="sec-4-2-1-3" name="sec-4-2-1-3"></a>test_sc.c<br  /><ol class="org-ol"><li><a id="sec-4-2-1-3-1" name="sec-4-2-1-3-1"></a>pointer foreign_testsc_set_testnum(scheme* sc, pointer args) <a id="foreign_testsc_set_testnum" name="foreign_testsc_set_testnum"></a> <a id="testsc-set-testnum" name="testsc-set-testnum"></a><br  /></li></ol>
</li></ol>
</div>
</div>


<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> 추가 구현</h3>
<div class="outline-text-3" id="text-4-3">
<p>
C 를 이용하여 추가적인 기능을 구현할 수 있다.
</p>
</div>
<div id="outline-container-sec-4-3-1" class="outline-4">
<h4 id="sec-4-3-1"><span class="section-number-4">4.3.1</span> 구조체 테스트 데이터 생성</h4>
</div>
</div>
</div>


<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> scheme 문법 <a id="scheme_syntax" name="scheme_syntax"></a></h2>
<div class="outline-text-2" id="text-5">
<div class="org-src-container">

<pre class="src src-scheme">;; This gives an introduction to Scheme in 15 minutes
;;
;; First make sure you read this text by Peter Norvig:
;; http://norvig.com/21-days.html
;;
;; Then install GNU Guile
;; NOTE: I won't encourage using Racket but if you really want,
;;       I still give you some hints in this tutorial. But the
;;       tutorial will base on Guile and RnRs.
;;
;; openSUSE: zypper install guile
;; Debian: apt-get install guile-2.0 (or see your distro instructions)
;; MacOSX: Building Guile 2.0 on the Mac
;;         http://irrealblog.blogspot.hk/2011/03/building-guile-2.html
;; Windows try web: http://repl.it/languages/Scheme
;;
;; More general information can be found at:
;; http://www.gnu.org/software/guile

;; Important warning:
;;
;; Going through this tutorial won't damage your computer unless
;; you get so angry that you throw it on the floor.  In that case,
;; I hereby decline any responsability.  Have fun!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 
;; Fire up Scheme:
;; Type 'guile' for GNU Guile
;; Or just use the browser for web version
;;
;; Now look at the prompt:

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Semi-colons start comments anywhere on a line.
;;
;; Scheme programs are made of symbolic expressions (s-exps):
(+ 2 2)

;; This symbolic expression reads as "Add 2 to 2".

;; Sexps are enclosed into parentheses, possibly nested:
(+ 2 (+ 1 1))

;; A symbolic expression contains atoms or other symbolic
;; expressions.  In the above examples, 1 and 2 are atoms,
;; (+ 2 (+ 1 1)) and (+ 1 1) are symbolic expressions.

(+ 3 (+ 1 2))
;; =&gt; 6

;; `set!' stores a value into a variable:
;; Please define my-name first, or you can't assign it.
(define my-name "unknown")
(set! my-name "NalaGinrut")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 1. Primitive Datatypes and Operators
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Numbers
9999999999999999999999 ; integers
#b111                  ; binary =&gt; 7
#o111                  ; octal =&gt; 73
#x111                  ; hexadecimal =&gt; 273
3.14                   ; reals
6.02e+23
1/2                    ; rationals
1+2i                   ; complex numbers

;; Function application is written (f x y z ...)
;; where f is a function and x, y, z, ... are operands
;; If you want to create a literal list of data, use ' to stop it from
;; being evaluated
'(+ 1 2) ; =&gt; (+ 1 2)
;; Now, some arithmetic operations
(+ 1 1)  ; =&gt; 2
(- 8 1)  ; =&gt; 7
(* 10 2) ; =&gt; 20
(expt 2 3) ; =&gt; 8
(quotient 5 2) ; =&gt; 2
(remainder 5 2) ; =&gt; 1
(/ 35 5) ; =&gt; 7
(/ 1 3) ; =&gt; 1/3
(exact-&gt;inexact 1/3) ; =&gt; 0.3333333333333333
(+ 1+2i  2-3i) ; =&gt; 3-1i

;;; Booleans
#t ; for true
#f ; for false -- any value other than #f is true
(not #t) ; =&gt; #f
(and 0 #f (error "doesn't get here")) ; =&gt; #f
(or #f 0 (error "doesn't get here"))  ; =&gt; 0

;;; Characters
;; According to RnRs, characters only have two notations:
;; #\ and #\x
;; Racket support #\u, but it's never Scheme.
#\A ; =&gt; #\A
#\λ ; =&gt; #\λ
#\x03BB ; =&gt; #\λ

;;; Strings are fixed-length array of characters.
"Hello, world!"
"Benjamin \"Bugsy\" Siegel"   ; backslash is an escaping character
"Foo\tbar\x21\a\r\n" ; includes C escapes (only support hex)
;; try to print the above string
;; Printing is pretty easy
(display "I'm Guile. Nice to meet you!\n")
;; and unicode escapes
"\u004B" ; =&gt; K

;; Strings can be added too!
(string-append "Hello " "world!") ; =&gt; "Hello world!"

;; A string can be treated like a list of characters
(string-ref "Apple" 0) ; =&gt; #\A

;; format can be used to format strings:
(format #t "~a can be ~a" "strings" "formatted")
;; ==&gt; print "strings can be formatted" on screen
(define str (format #f "~a can be ~a" "strings" "formatted"))
;; str was assigned to "strings can be formatted"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 2. Variables
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; You can create a variable using define
;; a variable name can use any character except: ()[]{}",'`;#|\
(define some-var 5)
some-var ; =&gt; 5

;; Accessing a previously unassigned variable is an exception
					; x ; =&gt; x: undefined ...

;; Local binding: `me' is bound to "Bob" only within the (let ...)
(let ((me "Bob"))
  "Alice"
  me) 
;; =&gt; "Bob"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 3. Structs and Collections
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Record Type (Skip this chapter if you're trying web version
(use-modules (srfi srfi-9))
(define-record-type dog 
  (make-dog name breed age)
  dog?
  (name dog-name)
  (breed dog-breed)
  (age dog-age))
(define my-pet
  (make-dog "lassie" "collie" 5))
my-pet ; =&gt; #&lt;dog&gt;
(dog? my-pet) ; =&gt; #t
(dog-name my-pet) ; =&gt; "lassie"

;;; Pairs (immutable)
;; `cons' constructs pairs, `car' and `cdr' extract the first
;; and second elements
(cons 1 2) ; =&gt; '(1 . 2)
(car (cons 1 2)) ; =&gt; 1
(cdr (cons 1 2)) ; =&gt; 2

;;; Lists

;; Lists are linked-list data structures, made of `cons' pairs and end
;; with a '() to mark the end of the list
(cons 1 (cons 2 (cons 3 '()))) ; =&gt; '(1 2 3)
;; `list' is a convenience variadic constructor for lists
(list 1 2 3) ; =&gt; '(1 2 3)
;; and a quote can also be used for a literal list value
'(1 2 3) ; =&gt; '(1 2 3)

;; Can still use `cons' to add an item to the beginning of a list
(cons 4 '(1 2 3)) ; =&gt; '(4 1 2 3)

;; Use `append' to add lists together
(append '(1 2) '(3 4)) ; =&gt; '(1 2 3 4)

;; Lists are a very basic type, so there is a *lot* of functionality for
;; them, a few examples:
;; For Racket users:
(map add1 '(1 2 3))          ; =&gt; '(2 3 4)
;; For Guile users:
(map 1+ '(1 2 3))        ; =&gt; '(2 3 4)
;; add1 or 1+ is not a standard primitive, so it depends on implementations.

(map + '(1 2 3) '(10 20 30)) ; =&gt; '(11 22 33)

;; filter/count/take/drop are dwell in SRFI-1, so you have to load it first.
;; For Racket users:
(require srfi/1)
;; For Guile users:
(use-modules (srfi srfi-1))

(filter even? '(1 2 3 4))    ; =&gt; '(2 4)
(count even? '(1 2 3 4))     ; =&gt; 2
(take '(1 2 3 4) 2)          ; =&gt; '(1 2)
(drop '(1 2 3 4) 2)          ; =&gt; '(3 4)

;;; Vectors

;; Vectors are fixed-length arrays
#(1 2 3) ; =&gt; '#(1 2 3)

;; Use `vector-append' to add vectors together
;; NOTE: vector-append is in SRFI-43 which is not supported in Guile-2.0.9
;;       or earlier. And it may not be added in Guile-2.0.10.
;;       But it's proposed in R7RS, and there's a r7rs branch in Guile upstream.
;;       If your Guile doesn't support vector-append, please skip this step.
(vector-append #(1 2 3) #(4 5 6)) ; =&gt; #(1 2 3 4 5 6)

;;; Hashes

;; Create mutable hash table
;; For GNU Guile
(define m (make-hash-table))
(hash-set! m 'a 1)
(hash-set! m 'b 2)
(hash-set! m 'c 3)

;; Retrieve a value
(hash-ref m 'a) ; =&gt; 1

;; Retrieving a non-present value is an exception
(hash-ref m 'd) 
;; =&gt; #f 

;; You can provide a default value for missing keys
(hash-ref m 'd 0)
;; =&gt; 0

;; Use `hash-remove' to remove keys (functional too)
(hash-remove! m 'a) ; =&gt; ((b . 2) (c . 3))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 3. Functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Use `lambda' to create functions.
;; A function always returns the value of its last expression
(lambda () "Hello World") ; =&gt; #&lt;procedure&gt;

;; Use parens to call all functions, including a lambda expression
((lambda () "Hello World")) ; =&gt; "Hello World"
((lambda (x) (+ x x)) 5)      ; =&gt; 10

;; Assign a function to a var
(define hello-world (lambda () "Hello World"))
(hello-world) ; =&gt; "Hello World"

;; You can shorten this using the function definition syntatcic sugar:
(define (hello-world2) "Hello World")
(hello-world2) ; =&gt; "Hello World"

;; The () in the above is the list of arguments for the function
(define hello
  (lambda (name)
    (string-append "Hello " name)))
(hello "Steve") ; =&gt; "Hello Steve"
;; ... or equivalently, using a sugared definition:
(define (hello2 name)
  (string-append "Hello " name))

;; You can have multi-variadic functions too, using `case-lambda'
(define hello3
  (case-lambda
    (() "Hello World")
    ((name) (string-append "Hello " name))))
(hello3 "Jake") ; =&gt; "Hello Jake"
(hello3) ; =&gt; "Hello World"
;; ... or specify optional arguments with a default value expression
(define* (hello4 #:key (name "World"))
  (string-append "Hello " name))

;; Functions can pack extra arguments up in a list
(define (count-args . args)
  (format #t "You passed ~a args: ~a" (length args) args))
(count-args 1 2 3) ; =&gt; "You passed 3 args: (1 2 3)"
;; ... or with the unsugared `lambda' form:
(define count-args2
  (lambda args
    (format #t "You passed ~a args: ~a" (length args) args)))

;; You can mix regular and packed arguments
(define (hello-count name . args)
  (format #t "Hello ~a, you passed ~a extra args" name (length args)))
(hello-count "Finn" 1 2 3)
					; =&gt; "Hello Finn, you passed 3 extra args"
;; ... unsugared:
(define hello-count2
  (lambda (name . args)
    (format #t "Hello ~a, you passed ~a extra args" name (length args))))

;; And with keywords
;; the keywords are those like this #:its-name, sometimes you may see
;; :its-name without '#' in certain Scheme implementation.
;; NOTE: keywords is not in any Scheme standards like RnRs.
;;       But mainstream Scheme implementation often contains it. 
;;   This truth also means that different implementation may has
;;   different result.
;;       The code below will follow Guile situation.
(define* (hello #:key (name "World") (greeting "Hello") . args)
  (format #t "~a ~a, ~a extra args~%" greeting name (length args)))
;; 'define*' is similar with 'define', but you may use it for defining
;; optional args or using keyword to specify the value to specified argument.
(hello)                 ; =&gt; "Hello World, 0 extra args"
(hello 1 2 3)           ; =&gt; "Hello World, 3 extra args"
(hello #:greeting "Hi") ; =&gt; "Hi World, 2 extra args"
;; NOTE: In Guile, all the keyword-value pairs are countered as the rest args.
;;       It means 'args' here will be (#:greeting "Hi"), so its length is 2.
;;       If you are in Racket, it's different, so the result will be 0.
;;       Because it's not defined in RnRs, so it's implementation specific.
(hello #:name "Finn" #:greeting "Hey") ; =&gt; "Hey Finn, 4 extra args"
(hello 1 2 3 #:greeting "Hi" #:name "Finn" 4 5 6) ; =&gt; "Hi Finn, 10 extra args"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 4. Equality
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; for numbers use `='
(= 3 3.0) ; =&gt; #t
(= 2 1) ; =&gt; #f

;; for characters use `char=?'
(char=? #\c #\c) ; =&gt; #t

;; for object identity use `eq?'
;; WARNING: don't use `eq?' on numbers and characters, the reason is very simple:
;;          because RnRs treat this rule as undefined! 
;;(eq? 3 3) ; =&gt; Wrong! it's undefined! So it depends on implementation!
;; No matter if you got #t from above, it's a wrong usage!!!
;; Should use (= 3 3) or (eqv? 3 3)

(eq? (list 3) (list 3)) ; =&gt; #f
;; Why it's #f? Because comparison between objects depends on their head-pointers.
;; These two lists are different objects, and they have different head-pointers.

(eq? 'a 'a) ; =&gt; #t
;; Symbols are the typical objects to compare with their head-pointers

;; eqv?
;; The difference between `eqv?' and `eq':
;; You can compare numbers and characters with `eqv?'
;; When you use `eqv?' for any objects other than numbers&amp;characters, it's the
;; same with `eq?'.
(eqv? 3 3)     ; =&gt; #t
(eqv? #\c #\c) ; =&gt; #t
(eqv? 'a 'a)   ; =&gt; #t

;; for collections use `equal?'
;; `equal?' will compare all the values in a collections type like record or list.
;; You can compare any objects with `equal?' safely, but inefficiency.
(equal? (list 'a 'b) (list 'a 'b)) ; =&gt; #t
(equal? (list 'a 'b) (list 'b 'a)) ; =&gt; #f

;; Choosing proper equal pred for you code, is one of the art in Scheme programming!

(eqv? "abcd" "abcd") ; =&gt; unspecified
;; Obviously, strings are collections type, so...it's your EXECISE now!

;; Another EXECISE, what's the proper 'equal-pred' for functions?
(what-to-use? (lambda (x) (1+ x)) (lambda (x) (1+ x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 5. Control Flow
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Conditionals

(if #t               ; test expression
    "this is true"   ; then expression
    "this is false") ; else expression
					; =&gt; "this is true"

;; In conditionals, all non-#f values are treated as true
(member 'Groucho '(Harpo Groucho Zeppo)) ; =&gt; '(Groucho Zeppo)
(if (member 'Groucho '(Harpo Groucho Zeppo))
    'yep
    'nope)
					; =&gt; 'yep

;; `cond' chains a series of tests to select a result
(cond ((&gt; 2 2) (error "wrong!"))
      ((&lt; 2 2) (error "wrong again!"))
      (else 'ok)) ; =&gt; 'ok

;;; Pattern Matching
;; For Racket users:
(require racket/match) ; use match module
(define (fizzbuzz? n)
  (match (list (remainder n 3) (remainder n 5))
    ((list 0 0) 'fizzbuzz)
    ((list 0 _) 'fizz)
    ((list _ 0) 'buzz)
    (else #f)))

;; For Guile users:
(use-modules (ice-9 match)) ; use match module
(define (fizzbuzz? n)
  (match (list (remainder n 3) (remainder n 5))
    ((0 0) 'fizzbuzz)
    ((0 _) 'fizz)
    ((_ 0) 'buzz)
    (else #f)))

(fizzbuzz? 15) ; =&gt; 'fizzbuzz
(fizzbuzz? 37) ; =&gt; #f

;;; Loops

;; Looping can be done through (tail-) recursion
(define (lp i)
  (when (&lt; i 10)
    (format #t "i=~a\n" i)
    (lp (1+ i))))
(lp 5) ; =&gt; i=5, i=6, ...

;; Similarly, with a named let
(let lp ((i 0))
  (when (&lt; i 10)
    (format #t "i=~a\n" i)
    (lp (1+ i)))) ; =&gt; i=0, i=1, ...

;; how to get a range? just like range(0, 9)?
;; the original 'iota' only accept one para
(iota 10) ; ==&gt; (0 1 2 3 4 5 6 7 8 9)
;; the 'iota' in srfi-1 was extended 
(use-modules (srfi srfi-1))
;; #&lt;procedure iota (count #:optional start step)&gt;
(iota 5 10) ; =&gt; (10 11 12 13 14) 
;; means from 10 count 5 times, each step +1 (plus one is default)
(iota 5 10 2) ; =&gt; (10 12 14 16 18)
;; from 10 count 5 times, each step +2
;; If you need a Python like range(5, 10) ==&gt; (5 6 7 8 9), try:
(define (range from to) (map (lambda (x) (+ from x)) (iota (- to from))))
;; EXECISE: you may find this 'range' implementation is not so good,
;;          please optimize it if you can.
(range 5 10) ; =&gt; (5 6 7 8 9)

;; how to do iteration?
(for-each display '(1 2 3 4 5))
;; =&gt; 12345
(for-each (lambda (i) (format #t "i=~a\n" i))
	  (iota 10)) ; =&gt; i=0, i=1, ...
(for-each (lambda (i) (format #t "i=~a\n" i))
	  (range 5 10)) ; =&gt; i=5, i=6, ...

;;; Iteration Over Other Sequences
;; `for' allows iteration over many other kinds of sequences:
;; lists, vectors, strings, sets, hash tables, etc...
(for-each display '(l i s t))
;; =&gt; list
(define vector-for-each (@ (rnrs) vector-for-each))
;; export vector-for-each from rnrs only
(vector-for-each display #(v e c t o r))
;; =&gt; vector
(string-for-each display "string")
;; =&gt; string
;;; More Iterations
(do ((i 10 (1+ i)) (j '(x y z) (cdr j))) 
    ((null? j)) ; if j is '(), just end the loop
  (format #t "~a:~a " i (car j)))
					; =&gt; 0:x 1:y 2:z

;;; Exceptions

;; To catch exceptions, use the 'catch' form
(catch 'my-error 
  (lambda () (throw 'my-error))
  (lambda e (display "oh~my error!\n")))
					; =&gt; oh~my error!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 6. Mutation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Use `set!' to assign a new value to an existing variable
(define n 5)
(set! n (1+ n))
n ; =&gt; 6

;; Use fluid for explicitly mutable values
(define n* (make-fluid 5))
(fluid-set! n* (1+ (fluid-ref n*)))
(fluid-ref n*) ; =&gt; 6

;; Many Guile datatypes are immutable (pairs, lists, etc), some come in
;; both mutable and immutable flavors (strings, vectors, hash tables,
;; etc...)

;; Use `vector' or `make-vector' to create mutable vectors
(define vec (vector 2 2 3 4))
(define wall (make-vector 100 'bottle-of-beer))
;; Use vector-set! to update a slot
(vector-set! vec 0 1)
(vector-set! wall 99 'down)
vec ; =&gt; #(1 2 3 4)

;; Create an empty mutable hash table and manipulate it
(define m3 (make-hash-table))
(hash-set! m3 'a 1)
(hash-set! m3 'b 2)
(hash-set! m3 'c 3)
(hash-ref m3 'a)   ; =&gt; 1
(hash-ref m3 'd 0) ; =&gt; 0
(hash-remove! m3 'a)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 7. Modules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Modules let you organize code into multiple files and reusable
;; libraries; Make sure put all the module code in one file, since 
;; the modules split as files. And the module name should be same 
;; with the filename, say, module named (my-cake) is 'my-cake.scm',
;; and module named (mods my-cake) is 'mods/my-cake.scm',
;; (mods submods my-cake) ==&gt; 'mods/submods/my-cake.scm'.
;; ---begin my-cake.scm---
(define-module (my-cake) ; define a `cake' module based on racket/base
  #:use-module (ice-9 format) ; the pre-requisition of current module
  #:export (print-cake)) ; function exported by the module

(define (show fmt n ch) ; internal function
  (format #t fmt (make-string n ch))
  (newline))

(define (print-cake n)
  (show "   ~a   " n #\.)
  (show " .-~a-. " n #\|)
  (show " | ~a | " n #\space)
  (show "---~a---" n #\-))
;; --end my-cake.scm---

;; Be sure that the path of 'my-cake.scm' is in your current 
;; %load-path list. Use `use-modules' to get all `provide'd names 
;; from a module.
(use-modules (my-cake)) ; the ' is for a local submodule
(print-cake 3)
					; (show "~a" 1 #\A) ; =&gt; error, `show' was not exported

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 8. Classes and Objects
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TODO
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 9. Macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Macros let you extend the syntax of the language

;; Let's add a while loop
(define-syntax-rule (while condition body ...)
  (let loop ()
    (when condition
      body ...
      (loop))))

(let ((i 0))
  (while (&lt; i  10)
    (display i)
    (set! i (1+ i))))

;; Macros are hygienic, you cannot clobber existing variables!
(define-syntax-rule (swap! x y) ; -! is idomatic for mutation
  (let ((tmp x))
    (set! x y)
    (set! y tmp)))

(define tmp 1)
(define a 2)
(define b 3)
(swap! a b)
(format #t "tmp = ~a; a = ~a; b = ~a\n" tmp a b) ; tmp is unaffected

;; But they are still code transformations, for example:
(define-syntax-rule (bad-while condition body ...)
  (when condition
    body ...
    (bad-while condition body ...)))
;; this macro is broken: it generates infinite code, if you try to use
;; it, the compiler will get in an infinite loop
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 용어</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> 테스트케이스</h3>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 테스트스크립트</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2017-06-02 금 21:40</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.2.50.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
