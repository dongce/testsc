* CODESCROLL 동저 시험 
** permutation 
[[file:mb/t-4.scm::(if%20(=%20tnum-start%20(testsc-get-testnum))]]
** admin_t 
#+BEGIN_SRC cpp
struct admin_t {
  union{
    wipe_proposal_t        _wipe_proposal ; 
    network_track_number_t _network_track_number ;
    pair_assoc_t           _pair_assoc ;
    monitor_t              _monitor ;
    aircraft_control_t     _aircraft_control ;
    command_order_t        _command_order ;
    // emitter_eval_info_type _emitter_eval_info ;
    // ew_coord_info_type     _ew_coord_info ;
    link_pointer_t         _link_pointer ; 
    depromotion_t          _depromotion ; 
    update_request_t       _update_request ; 
    weapon_engagement_t    _weapon_engagement ;
    new_assignment_t       _assign_request ;
    track_alert_report_t   _alert_report ; 
    ew_intelligence_types::ew_intelligence_request_record _ew_request; 
  } ; 
} ;

#+END_SRC
** 100 이지만 이상종료하는 것 
looptest::looptest_ptt
** TODO [#A] trunk 반영 필요. 
intds_intf.h
build_message_track.cpp
build_message_training.cpp 
process_message_m4d.cpp 
looptest.cpp
looptest.h
general_input.cpp
network_track_data_base.h
usr_channel.h
usr_channel.cpp
general_input.cpp 
DP_L11EventHandler.cpp
track_controller.cpp
process_message_m9a.cpp
dlp_unit.cpp
mmsg_buff.h
** 주의사항 
 - [ ] 스크립트 폴더별로 작성 주의 
 - [ ] 시작전 최신 파일 체크아웃 (.cpp, .h)
dts_controller.cpp

[[file:/opt/vboxshare/gitdir/DLP_LINK11/src/csds_manager/OWNFFXDefine.h::#define%20_LINK11%201][_STEST_]] OWNDefine.h

** 구현 필요. 
*** TODO nth 
 C 로 구현해서 성능 향상 필요. 
*** TODO ew intelligence 관련 
** shortcut 
*** 링크 플래그 
*.csp 파일에 대하여 수행 
#+BEGIN_SRC sql
update Module set linkFlag='-Lc:/ts/ -ltinyscheme' ; 
#+END_SRC


#+BEGIN_SRC sql
sqlite3 xxx.csp update Module set linkFlag='-Lc:/ts/ -ltinyscheme' ; 
#+END_SRC

*** 자주 사용하는 코드 

#+BEGIN_SRC cpp

if(testsc_ivalue("testsc") > 0) return testsc_ivalue("") ; 

#+END_SRC
** stub
*** get_admission
#+BEGIN_SRC cpp
admission_t  os_data::get_admission()
{
	admission_t cs_returnValue = {0, };
	cs_returnValue.max_ntn_track = 500 ; 
	cs_returnValue.ntn_track_threshold_percent = 80 ;
	cs_returnValue.max_tx_ntn_track = 500 ;
	cs_returnValue.tx_ntn_track_threshold_percent = 80 ; 

	return cs_returnValue;
}
#+END_SRC
*** read_channel
#+BEGIN_SRC cpp
char* testsc_admin_get( int i ) ;
void testsc_debug(const char*format ...) ;

int  read_channel(const char * arg0, char * arg1, unsigned int arg2)
{
	static int count = 1 ;
	if( testsc_ivalue("testsc") > 0 ){
		char *it = testsc_admin_get(count++) ;
		new_assignment_t* it2 = (new_assignment_t*) it ;

		if(0 == it ) return 0 ;
		testsc_debug("%d:%d:%d %s:%d", it2->tactical, it2->assignment_kind, arg2, __FILE__, __LINE__ ) ;
		memcpy(arg1, it, arg2) ;
		//new_assignment_t* it2 = (new_assignment_t*) it ;

		testsc_debug("%d:%d:%d %s:%d", it2->tactical, it2->assignment_kind, arg2, __FILE__, __LINE__ ) ;
		return arg2 ;
	}
	return 0;
}

#+END_SRC
*** message_admin
#+BEGIN_SRC cpp

if(testsc_ivalue("testsc")>0) return testsc_ivalue("mas") ; 

char* testsc_admin_get( int i ) ;

if( testsc_ivalue("testsc") > 0 ){return testsc_admin_get(arg0) ;}

#+END_SRC
*** ntdb

#+BEGIN_SRC cpp
  static int id = 1 ; 

  if(testsc_ivalue("testsc") > 0 ){
    if( testsc_ivalue("con") > 0 ){
      return testsc_track_get(testsc_ivalue("con") ) ;
    }
    return testsc_track_get(id++) ; 
  }
  return 0 ; 
#+END_SRC

*** mmsg_buff
single()  구현 필요. 

#+BEGIN_SRC c++
long mmsg_get_field_value( int a, int b ) ; 

if(testsc_ivalue("testsc")) return  mmsg_get_field_value( arg0, arg1 )  ; 
#+END_SRC


** testcase 수정 방법 
다음과 같은 주석이 있으면 사용자 코드가 삭제가 아니되는 것으로 보임 
#+BEGIN_SRC cpp

/*
	TODO : Constructor Code Here
	Class name : vector<uintptr_t, allocator<uintptr_t> > 
	Object name : networks
*/

/*	FIXME : Abnormal code	*/
	vector<uintptr_t, allocator<uintptr_t> > networks=vector<uintptr_t, allocator<uintptr_t> >();



for(int i = 0 ; i < 10 ; i ++){
  networks.push_back(i) ; 
}
	/* build_message_tag::output_tag_transfers(const vector<unsigned long, allocator<unsigned long> > &) */
	object_build_message_tag.output_tag_transfers(networks);

#+END_SRC
** 진행방법 

 1. 파일 체크아웃
 2. 타임아웃 설정
 3. 일괄 테스트 수행
 4. 셀프스텁 기록 필요.
 5. 셀프서텁 사용 후 원복
 6. 파일 완료 후에는 커밋 필수 



** 진척률 [29/91]

*** DONE DP_L11EventHandler
    CLOSED: [2016-04-12 Tue 00:34]
    - State "STARTED"    from "TODO"       [2016-04-04 Mon 20:03]
 - [X] 일괄 실행 



*** TODO LINK11_DSF_MANAGER
*** TODO SQLite3Interface
*** DONE build_message_aircrafta_control
    CLOSED: [2016-04-16 Sat 20:44]
    - State "STARTED"    from "REVIEW"     [2016-04-15 Fri 22:04]
**** 확인 사항  
    - [X] 타이머 설정 
    - [ ] 일괄 실행 
    - [X] 체크아웃 

**** script 
***** output_aircraft_control_orders(void)

(1)
(anset 1 '_aircraft_control.counter 1 )
(anset 1 '_aircraft_control.order system_types-assume_cntrl  )

(anset 1 '_aircraft_control.counter 0 )
(anset 1 '_aircraft_control.order system_types-assume_cntrl  )

(tnset 1 _air_mission_data.air_control_active 1 )

(2)

build_m10a_original_and_ack 0 

(3)
build_m10a_original_and_ack 1

(4)
(anset 1 '_aircraft_control.counter 7 )


***** process_aircraft_control_order()

(1)
rh0 1
rh1 0 
vco 1

(2)
rh0 1 
vco 1




***** process_ackn_aircraft_control_order()

(1)
rh0 1
rh1 0 
vco 1

(2)
rh0 1 
vco 1




***** process_rc_request_for_original()
(1)
anset 0 _aircraft_control.M10AFRAME ORDER_CANCEL_INDICATO
anset 1 
ita 1 

(1)
anset 0 _aircraft_control.M10AFRAME ORDER_CANCEL_INDICATO
anset 1 
ita 0

alloc ait 



***** process_rc_request_for_reply()
(0)
(anset 0 _aircraft_control.reply system_types::machine_receipt)
(anset 1 _aircraft_control.reply system_types::will_comply)

ita 1

(1)
(anset 0 _aircraft_control.reply system_types::machine_receipt)
(anset 1 _aircraft_control.reply system_types::will_comply)

ita 0 
alloc 0 

(2)
(anset 0 _aircraft_control.reply system_types::machine_receipt)
(anset 1 _aircraft_control.reply system_types::will_comply)

ita 0 
alloc ait





***** validate_ackn_control_order(const aircraft_control_t & ackn_control_order )

(1)
search_booked_order 0 

(2)
search_booked_order sboit 


(3)
 ackn_control_order.order == system_types::control_and_engage  

(4)
itn 0 

(4)
itn 1 

(5)
ackn_control_order.order == system_types::transfer_cntrl

(6)
ipv 1 

(6)
ipv 0


(7)


***** process_validated_ackn_control_order(const aircraft_control_t & ackn_to_process)
(1)
alloc 0
(2)
alloc arit 

(anset 1 _aircraft_control.reply system_types::will_comply)
(anset 1 _aircraft_control.order -1y)


(3)
(tnset 0 )


(4)
(tnset 0 supporting_info.info_validation 1)


***** process_aircraft_cancel_transmission
(anset 0 )



*** DONE build_message_aircraft_status
    CLOSED: [2016-04-16 Sat 23:13]
    - State "STARTED"    from "REVIEW"     [2016-04-16 Sat 21:01]
**** 확인 사항  
    - [X] 타이머 설정 
    - [ ] 일괄 실행 
    - [X] 체크아웃 


**** script 
***** output_aircraft_status(const keyvector_t& networks )

(1)
(tnset 1 '_air_mission_data.air_control_active 1 )
(tnset 1 '_air_mission_data.kind AIRCRAFT_STATUS_KIND_AIR_GENERAL )
(tnset 1 '_air_mission_data.general_mission.mission_status_validity 1)
      
(2)
(tnset 1 '_air_mission_data.general_mission_counter 1)
(tnset 1 '_air_mission_data.general_mission_counter 0)

(3)
(tnset 1 '_air_mission_data.air_control_active 1)
(tnset 1  '_air_mission_data.kind AIRCRAFT_STATUE_KIND_ASW )

(4)
(tnset 1 '_air_mission_data.asw_mission_counter 1 )
        decrease_counter(&t->_air_mission_data.asw_mission_counter);

(5)
(tnset 1 '_air_mission_data.asw_mission_counter 0 )
(tnset 1 '_air_mission_data.asw_mission_repetition_counter == 1U




***** output_controlling_unit_report(const keyvector_t& networks )

networks.push_back(1) ; 
networks.push_back(2) ; 
build_message_ownship::single()->get_transmission_counter() 

(define gtc 8 0)

(1)
(tnset 1 )
(tnset 2 'general.NTN 1 
         '_air_mission_data.control_counter 1 
         'general.pu_controlling -1)


}

***** process_aircraft_status_general(void)

validate_aircraft_status_genera 
(define vasg 1 )

read_channel

testsc_admin_get !=0 return size 

(anset 0 )

***** process_aircraft_status_asw(void)

  aircraft_status_asw_t status = STRUCT_ZERO_INIT_VALUE ; 

can_take_pu_controllin
(anset 0 )
(anset 1_aircraft_status_asw.network 1 )

(1)
(define ctpc 1 ) 
(anset 1_aircraft_status_asw.network 1 )

(2)
(define ctpc 0 ) 


***** set_aircraft_status_general(const aircraft_status_general_t &    air_mission )

(anset 0 )
(anset 1 _aircraft_status_general.network 1 
         _aircraft_status_general.fuel_validity 1 
         _aircraft_status_general.time_of_task_availability 1
)

(tnset 1 _air_mission_data.air_control_active 0 )
(tnset 1 _air_mission_data.air_control_active 1 )




***** validate_aircraft_status_general(const  aircraft_status_general_t &   air_mission  )
check_out_network 
testsc_track_get(arg0)

network_track_data_base::single()->is_there_networ
(define itn 1 )

(anet 0 )



***** stop_controlling_unit(const controlling_unit_t &   controlling_unit)
check_output_network

(tnset 0 _air_mission_data.air_control_active 1 )


void build_message_aircraft_status::set_controlling_unit_command(const controlling_unit_t &   controlling_unit)
{
  //@@@ 
  //@@@ for(항공통제 정보와 관련한 표적 정보 t){
  //@@@   if( can_take_pu_controlling 함수를 호출하여 확인한 결과 항공통제 가능하다 ){
  //@@@     if(항공봉제 정보가 시작 정보이다){
  //@@@       start_controlling_unit 함수를 호출하여 항공통제를 시작한다. 
  //@@@     }
  //@@@     else {
  //@@@       stop_controlling_unit 함수를 호출하여 항공통제를 중시한다. 
  //@@@     }
  //@@@   }
  //@@@ }
  //@@@ send_aircraft_mission_report 함수를 호출하여 항공통제 정보를 처리했음을 알린다. 

  ////////////////////////////////////////////////////////////////////////
  //	controlling unit 명령이다. 함수이름이 이상하다. 
  ////////////////////////////////////////////////////////////////////////
  const uint32_t    three_times = 3U;
  system_types::aircr_mis_result_e       aircr_mis_result  = system_types::rejected_aircr_mis_result;
  system_types::aircr_mis_reject_reason_e    aircr_mis_reject_reason = system_types::unknown_track_aircr_mis_reject_reason;

  if(network_track_data_base::single()->is_there_network( controlling_unit.network )){

    if(can_take_pu_controlling(controlling_unit.network)){
      aircr_mis_result  = system_types::controlling_unit_accepted;


      if ( system_types::start == controlling_unit.command ){
        start_controlling_unit(controlling_unit) ; 
      }
      else {
        stop_controlling_unit(controlling_unit) ; 
      }
        
    }
    else{
      aircr_mis_result  = system_types::rejected_aircr_mis_result;
      aircr_mis_reject_reason = system_types::already_being_controlled;
    }
  }
  else{
    printf("No Network Track\n") ; 
    printf("No Network Track\n") ; 
    printf("No Network Track\n") ; 
  }
    



  send_aircraft_mission_report (controlling_unit.NTN , 
                                aircr_mis_result,
                                aircr_mis_reject_reason);

}


***** set_controlling_unit_command(const controlling_unit_t &   controlling_unit)

network_track_data_base::single()->is_there_network( controlling_unit.network )
can_take_pu_controlling(controlling_unit.network
(1)
(define itn 1 )
(define ctpc 1 )

(2)
(define itn 0 )
(define ctpc 1 )



***** can_take_pu_controlling(const uint32_t network ) 

check_out_network 

(1)
(tnset 0)





*** REVIEW build_message_cdo

**** 확인 사항  
    - [ ] 타이머 설정 
    - [ ] 일괄 실행 
    - [X] 체크아웃 

**** script 

***** validate_change_data_order( change_data_t     &cdo)

(1)
(tnset 0 'link11.change_data_order_running 1 )

(2)
(tnset 0 'link11.change_data_order_running 0 )


***** process_validated_change_data_order( change_data_t &change_data_command)

(1)
(tnset 0  'general.link_state system_types-transmitted_link_state 0 )

(2)
(tnset 0  'general.link_state system_types-transmitted_link_state 0 )


***** process_change_data_orders(void)
validate_change_data_orde 
(define vcdo 1 )

(1)
(anset 0 )

***** build_message_M9AC2(network_track_data_ptr t )

t->_change_data_order_counter 

***** output_change_data_order(const keyvector_t& networks )

(tnset 0 _change_data_order_counter 1 )
(tnset 1 '_change_data_order_counter 0 
         'link11.change_data_order_running 1 
         '_change_data_order.network_cdo  1)




*** TODO build_message_command

**** stub
read_channel 
static int id=0 ; 
return testsc_admin_get(id++) ; 

**** script 

***** output_commands(void)

decrease_counter(&(o->command_counter)) ; 

if( testsc_ivalue("testsc")){
  args = 0 ; 
}


(1)
(anset 0 _command_order.order_reply -1 )
(anset 1 _command_order.order_reply  system_types::original )
(anset 1 _command_order.command_counter 8 )




***** remove_command( const command_order_t *cmd )

if(CS_TESTCASENO() == 1 ){
  cmd = 0 ; 
}


***** find_command_with_destination(const command_order_t &cmd , const uint32_t destination )

(1)
(anset 0 )
(anset 1 _command_order.ntn_platform 1 )


***** find_command_with_source(const command_order_t &cmd , const uint32_t source )

(anet 0 _command_order.order_reply -1 )
(anet 1 _command_order.order_reply system_types-machine_receipt )    
(anet 2_command_order.order_reply system_types-machine_receipt )    
(anet 2_command_order.ntn_platform  1 )    


***** find_command_with_frame(const command_order_t & cmd )

(anset 0 )
(anset 1 _command_order.aframe 1 )    


***** process_rc_request_for_received(void)
(anset 0 _command_order.order_reply system_types::will_comply       )
(anset 1 _command_order.order_reply -1      )
     

***** process_rc_request_cant_process(void)
(anset 0 )



***** get_command_frame(command_order_t & cmd )

if(testsc_ivalue("testsc")){
 cmd.command = testsc_ivalue("command") ; 
 cmd.weapon_platform = testsc_ivalue("wp") ;
 cmd.gmt_time_of_impact_valid = testsc_ivalue("gtoiv") ;  
}


(1)
(define command system_types::assume_duties)
(2)
(define command system_types::conduct_procedures )

(3)
(define command system_types::proceed_to_point  )

(4)
(define command system_types::weapons_free )

(5)
(define command system_types::hold_fire )
(define wp -1) 

(6)
(define command system_types::cease_fire )
(define wp system_types::any_platform) 

(7)
(define command  system_types::engage)
(define wp -1) 
(8)
(define command system_types::cease_engage  )
(define wp system_types::any_platform) 


(9)
(define command  system_types::engage_asm_ssm   )
(define gtoiv 1)

(10)
(define command  system_types::engage_specific )
(11)
(define command  -1)



***** validate_command( command_order_t &cmd )

if(testsc_ivalue("testsc")){
 cmd.command = testsc_ivalue("command") ; 
 cmd.weapon_platform = testsc_ivalue("wp") ;
 cmd.gmt_time_of_impact_valid = testsc_ivalue("gtoiv") ;  
}

  if (! network_track_data_base::single()->is_there_ntn( cmd.pu_destination ) && return testsc_ivalue("itn") ;  
  if(NULL != find_command_with_frame( cmd ) ){ return testsc_ivalue("fcwf") ; 

(tnset 0 )

(1)
(define itn 0 )
(define command -1)
(define fcwf 1 )

{2)

(define itn 0 )
(define command system_types::hold_fire)


{2)

(define itn 0 )
(define command system_types::hold_fire)




***** process_command_orders(void)

      if(true == validate_command ( command_order ) ){ return testsc_ivalue("vc") ; 

(1)
(for-each-index 
  (lambda (index cmd )
    (if (= (testsc-get-testnum ) (+ 1 index ))
      (anset index  '_command_order.command cmd )))
'( 
 system_types-assume_duties
 system_types-cease_duties  
 system_types-conduct_procedures
 system_types-cease_conducting_procedures
 system_types-weapons_free
 system_types-weapons_tight
 system_types-proceed_to_point
 system_types-cease_proceeding_to_point
 system_types-engage
 system_types-assign
 system_types-cease_engage
 system_types-hold_fire
 system_types-cease_fire
 system_types-cover
 system_types-salvo_clear          
 system_types-engage_specific      
 system_types-cease_engage_specific
 system_types-engage_asm_ssm 
-1)) 

***** validate_acknowledge_command( command_order_t &   ackn )

  if(!network_track_data_base::single()->is_there_ntn(ackn.ntn_target)){
   return testsc_ivalue("itn") ; 
  }

find_command_with_destination( ackn , ackn.pu_destination ) ; 
return testsc_admin_get(testsc_ivalue("fcwd") ; 

if(testsc_ivalue("command")){
  ackn.command = testsc_ivalue("command") ; 
}


(1)

(define command  system_types::weapons_free) || 

(2)
(define command  -1) 


(3)
(define command  -1) 
(anset 0 )

(4)
(define command  -1) 
(anset 0 _command_order.aframe 1 )



***** process_ackn_command_from_system(void)
validate_acknowledge_comman
return testsc_admin_get("vac") ;
 
read_channel 
if(testsc_ivalue("testsc")){
static int id = 0 ; 
testsc_admin_get(id++) ; 
}

(1)
(anset 0 )
(define vac 1 )



*** TODO build_message_difference_report
*** TODO build_message_emitter_eval
*** TODO build_message_ew_coord
*** TODO build_message_iff_sif
*** TODO build_message_link_pointer
*** TODO build_message_opnote
*** TODO build_message_ownship
*** TODO build_message_pairing_association
*** TODO build_message_reception_quality
*** TODO build_message_special_code
*** TODO build_message_supporting_information
*** DONE build_message_tag
    CLOSED: [2016-04-02 Sat 18:43]
    - State "STARTED"    from              [2016-04-02 Sat 12:13]
CASE_RETURN_WITH_VALUE 변경 

 - [ ] 일괄 실행 
*** DONE build_message_track                                       :SELFSTUB:
 스크립트 폴더 따로 작성하지 아니하였음. 
**** get_amplifying_message_period
const track_selection_t * build_message_track::find_track_transmission_characteristic(network_track_data_t * arg0)

**** output_tracks

- stubs 
#+BEGIN_SRC cpp

#+END_SRC

*** DONE build_message_training
    CLOSED: [2016-04-02 Sat 22:07]
    - State "STARTED"    from "TODO"       [2016-04-02 Sat 19:38]
 - [X] 일괄 실행 
*** DONE build_message_update_request
    CLOSED: [2016-04-02 Sat 23:38]
    - State "STARTED"    from "TODO"       [2016-04-02 Sat 22:08]
 - [X] 일괄 실행 


*** self stub 
**** process_data_update_requests 
validate_data_update_request


**** bool build_message_update_request::validate_data_update_request(update_request_t &   update_request )
 update_request_t * build_message_update_request::find_update_request(const update_request_t & arg0)
 {
	 return 1 ;
	 return 0;
 }

*** DONE build_message_weapon_engagement
    CLOSED: [2016-04-04 Mon 19:59]
    - State "STARTED"    from "TODO"       [2016-04-04 Mon 12:28]
 - [X] 일괄 실행 
*** STARTED dlp_unit
    - State "STARTED"    from "TODO"       [2016-04-11 Mon 22:38]

**** 확인 사항  
    - [X] 타이머 설정 
    - [X] 일괄 실행 
    - [X] 체크아웃 

*** DONE dlptime
    CLOSED: [2016-04-11 Mon 22:37]
    - State "STARTED"    from "TODO"       [2016-04-11 Mon 22:25]

**** 확인 사항  
    - [X] 타이머 설정 
    - [X] 일괄 실행 
    - [X] 체크아웃 

*** DONE dts_controller
    CLOSED: [2016-04-11 Mon 22:23]
    - State "STARTED"    from "TODO"       [2016-04-05 Tue 21:38]

**** 확인 사항  
    - [ ] 타이머 설정 
    - [ ] 일괄 실행 
    - [X] 체크아웃 

*** TODO dts_serial
*** TODO ew_intelligence_types
*** TODO ffx_unit
*** DONE general_input
    CLOSED: [2016-04-04 Mon 21:33]
    - State "STARTED"    from "TODO"       [2016-04-04 Mon 12:30]
 - [X] 일괄 실행 
 - [X] 타임 아웃 변경 
*** TODO general_library
*** TODO general_output
*** TODO gettimeofday
*** TODO intf_vme
*** DONE lifecycle_controller
    CLOSED: [2016-03-29 Tue 14:27]
*** DONE link11_filter
    CLOSED: [2016-04-02 Sat 19:28]

**** self strub
is_track_filter_exception 

*** DONE looptest
    CLOSED: [2016-04-03 Sun 02:22]
    - State "STARTED"    from "TODO"       [2016-04-02 Sat 19:29]
 - [X] 일괄 실행 


**** self stup 
***** looptest_ptr(

update
***** looptest_ptt(

update
*** DONE mmsg_buff
    CLOSED: [2016-04-05 Tue 21:35]
    - State "STARTED"    from "TODO"       [2016-04-04 Mon 21:37]
 - [X] 일괄 실행 
*** TODO network_rx
*** DONE network_track_data_base
    CLOSED: [2016-04-04 Mon 12:33]
    - State "STARTED"    from "TODO"       [2016-04-04 Mon 12:27]
*** DONE network_track_data_bash_hash
    CLOSED: [2016-04-05 Tue 19:47]
    - State "STARTED"    from "TODO"       [2016-04-04 Mon 12:41]
 - [X] 일괄 실행 

**** self stub 
***** allocate_ntn_transmi
***** check_out_addr



*** TODO network_tx
*** TODO ntds_intf
*** TODO ntn_controller
*** TODO os_data
*** TODO parameter_adapter
*** TODO periodic_controller
*** TODO pool
*** TODO process_message
*** TODO process_message_m10
*** TODO process_message_m11b
*** TODO process_message_m11c
*** TODO process_message_m11d
*** TODO process_message_m11m
*** TODO process_message_m12_0
*** TODO process_message_m12_30
*** TODO process_message_m12_31
*** TODO process_message_m13
*** TODO process_message_m14
*** TODO process_message_m15
*** TODO process_message_m1_rp0
*** TODO process_message_m1_rp1
*** TODO process_message_m2
*** TODO process_message_m3
*** DONE process_message_m4ab
    CLOSED: [2016-04-02 Sat 17:52]

**** self stub 
#+BEGIN_INFO 
bool process_message_m4ab::is_depth_valid(mmsg_buff *m) ;
bool process_message_m4ab::is_gmt_valid(mmsg_buff *m)
#+END_INFO

*** DONE process_message_m4c
    CLOSED: [2016-04-02 Sat 20:21]
    - State "STARTED"    from "TODO"       [2016-04-02 Sat 18:35]
 - [X] 일괄 실행 
 - [X] 일괄 실행 
*** DONE process_message_m4d
    CLOSED: [2016-04-03 Sun 00:09]
    - State "STARTED"    from "TODO"       [2016-04-02 Sat 20:24]
 - [X] 일괄 빌드 

*** DONE process_message_m5                                    :QUESTIONMARK:
    CLOSED: [2016-03-28 Mon 23:53]
 스크립트 폴더 pm5

? 가 생기는 원인 확인 필요. 
*** DONE process_message_m6a
    CLOSED: [2016-03-29 Tue 11:43]
*** DONE process_message_m6b
    CLOSED: [2016-04-06 Wed 08:47]
**** existing_track 
stup : get_last_created_network
*** DONE process_message_m6c
    CLOSED: [2016-04-16 Sat 20:18]
    - State "STARTED"    from "REVIEW"     [2016-04-16 Sat 19:25]
**** 확인 사항  
    - [ ] 타이머 설정 
    - [ ] 일괄 실행 
    - [X] 체크아웃 

**** script 
***** process_message
(1)
M1MN SECOND_FRAME_OFFSET MESSAGE_NUMBER_M8
M86CARPSW  SECOND_FRAME_OFFSET 0
(tnset 1 'general.track_kind system_types::track_kind_esm_bearing_track )

(2)
M1MN SECOND_FRAME_OFFSET MESSAGE_NUMBER_M8
M86CARPSW  SECOND_FRAME_OFFSET 1
(tnset 1 'general.track_kind system_types::track_kind_esm_bearing_track )




*** DONE process_message_m6d
    CLOSED: [2016-04-16 Sat 23:23]
    - State "STARTED"    from "REVIEW"     [2016-04-16 Sat 20:27]
**** 확인 사항  
    - [X] 타이머 설정 
    - [ ] 일괄 실행 
    - [X] 체크아웃 

**** script
***** process_message(network_track_data_ptr t1 , network_track_data_ptr t2 )

(1)
M6DTN 0 1
(2)
M6DTN 0 0
(3)
M6DTN 0 3
(4)
M6DTN 0 7
(5)
M6DTN 0 8
(6)
M6DTN 0 12
(7)
M6DTN 0 13
(8)
M6DTN 0 14
(9)
M6DTN 0 15
(9)
M6DTN 0 -1


***** process_request_periodic_report(uint32_t m6d_tn_tactical_id )

(1)
_m6d_rc -1
_m6d_tnadde 1

(2)
_m6d_rc -1
_m6d_tnadde 0


(3)    
_m6d_rc RC_COMPLIANCE_REQUIRED:
_m6d_tnadde 0
(4)
_m6d_rc RC_NO_COMPLIANCE:
_m6d_tnadde 0
(5)
_m6d_rc RC_MACHINE_RECEIPT:
_m6d_tnadde 0
(6)
_m6d_rc RC_CANT_COMPLY:
_m6d_tnadde 0





***** process_request_update_then_watch(uint32_t m6d_tn_tactical_id )

(1)
_m6d_rc -1
_m6d_tnadde 1

(2)
_m6d_rc -1
_m6d_tnadde 0

(3)
_m6d_rc -1
_m6d_tnadde 0

(4)
_m6d_rc  RC_COMPLIANCE_REQUIRED
_m6d_tnadde 0
(5)
_m6d_rc  RC_NO_COMPLIANCE
_m6d_tnadde 0
(6)
_m6d_rc  RC_MACHINE_RECEIPT
_m6d_tnadde 0
(7)
_m6d_rc  RC_CANT_COMPLY
_m6d_tnadde 0




***** process_cancel_request_cease_report(uint32_t m6d_tn_tactical_id )

(1)
 _m6d_rc -1 
_m6d_tnaddee 1

(2)

_m6d_rcV 0

(3)
_m6d_rcV 1


(4)
 _m6d_rc RC_COMPLIANCE_REQUIRED
(5)
 _m6d_rc RC_NO_COMPLIANCE
(6)
 _m6d_rc RC_MACHINE_RECEIPT
(7)
 _m6d_rc RC_CANT_COMPLY




***** process_emitter_evaluation(uint32_t m6d_tn_tactical_id )
(1)
m6d_tn_tactical_id 0 


(2)
_m6d_mul 0
(3)
_m6d_mul 1




***** process_ew_request_response(uint32_t m6d_rtn_tactical_id)

(1)
m6d_rtn_tactical_id 0

(2)
m6d_rtn_tactical_id 1

(3)
_m6d_rcV 0 

(4)
_m6d_rcV 3

(5)
_m6d_rcV 14

(6)
_m6d_rcV 15





***** process_evaluate_track_received(uint32_t m6d_tn_tactical_id)

(1)   
_m6d_rc -1 
_m6d_tnaddee 1

(2)   
_m6d_rc -1 
_m6d_tnaddee 0



(3)   
_m6d_rc  RC_COMPLIANCE_REQUIRED
(4)   
_m6d_rc  RC_NO_COMPLIANCE
(5)   
_m6d_rc  RC_MACHINE_RECEIPT
(6)   
_m6d_rc  RC_CANT_COMPLY




***** process_evaluate_sector_received()

(1)   
_m6d_rc -1 
_m6d_tnaddee 1

(2)   
_m6d_rc  RC_COMPLIANCE_REQUIRED
(3)   
_m6d_rc  RC_NO_COMPLIANCE
(4)   
_m6d_rc  RC_MACHINE_RECEIPT
(5)   
_m6d_rc  RC_CANT_COMPLY









*** DONE process_message_m9a
    CLOSED: [2016-04-16 Sat 17:53]
    - State "STARTED"    from "TODO"       [2016-04-05 Tue 19:51]

[[file:/opt/vboxshare/codescroll/process_message_m9a/.csdata/src/instrumented/process_message_m9a_1.cpp::/%20private%20:]]
**** 확인 사항  
    - [X] 타이머 설정 
    - [X] 일괄 실행 
    - [X] 체크아웃 


*** REVIEW process_message_m9b

**** 확인 사항  
    - [ ] 타이머 설정 
    - [ ] 일괄 실행 
    - [X] 체크아웃 


**** script 

***** process_message(network_track_data_ptr a , network_track_data_ptr b )

(1)
a 0
b 0

(2)
M9BAC   0 0 
(3)
M9BAC   0 -1
(4)
M9BAC   0  6
(5)
M9BAC   0  15 

(anset 1 )
      

*** REVIEW process_message_m9c
**** 확인 사항  
    - [ ] 타이머 설정 
    - [ ] 일괄 실행 
    - [X] 체크아웃 




**** script 
***** process_message()

(1)

(mmsg-set '(M9CPUADDE 0 1))


*** REVIEW process_message_m9d

**** 확인 사항  
    - [ ] 타이머 설정 
    - [ ] 일괄 실행 
    - [X] 체크아웃 


**** script 

***** process_message()

(1)
(mmsg-set (M9DSW 0 SOFTWARE_END_OF_TRANSMISSION))
(2)
(mmsg-set (M9DSW 0 SOFTWARE_END_OF_TRANSMISSION))



      
*** REVIEW process_message_m9e

**** 확인 사항  
    - [ ] 타이머 설정 
    - [ ] 일괄 실행 
    - [X] 체크아웃 

**** script 
***** process_voice_control_frequency_received
t = 0 
***** process_mission_number_received
t = 0 
***** process_call_sign_receive
t = 0 
 
*** REVIEW process_message_m9f

**** 확인 사항  
    - [ ] 타이머 설정 
    - [ ] 일괄 실행 
    - [X] 체크아웃 

**** script

***** existing_track( network_track_data_ptr t )
(2)
 M9FACT 0  M9F_BASIC 
(3)
 M9FACT 0  M9F_SECONDARY



***** fill_network_track_data(network_track_data_ptr t )

(define  Env_Cat_Air         = 1)
(define  Env_Cat_Surface     = 2)
(define  Env_Cat_Subsurface  = 3)
(define  Src_EW          = 1)
(define  Src_Intel       = 2)
(define  Src_Sosus       = 3)
(define  Src_ASW_Sensor      = 4)

(1)
( M89FCAT , SECOND_FRAME_OFFSET Env_Cat_Air)
(2)
( M89FCAT , SECOND_FRAME_OFFSET Env_Cat_Surface)
(3)
( M89FCAT , SECOND_FRAME_OFFSET Env_Cat_Subsurface)
(4)
( M89FCAT , SECOND_FRAME_OFFSET -1)

(5)
M89FSRC , SECOND_FRAME_OFFSET   Src_EW
(6)
M89FSRC , SECOND_FRAME_OFFSET   Src_Intel
(7)
M89FSRC , SECOND_FRAME_OFFSET   Src_Sosus
(8)
M89FSRC , SECOND_FRAME_OFFSET   Src_ASW_Sensor


***** fill_network_track_data_secondary(network_track_data_ptr t )
(1)
 M9FSW 0 0 
(2)
 M9FSW 0 1



*** REVIEW process_message_m9g

**** 확인 사항  
    - [ ] 타이머 설정 
    - [ ] 일괄 실행 
    - [X] 체크아웃 

**** script 
***** process_message()
(define  South  1)
(define  West   1)

(1)
M9GLATMI 0 60

M9GN 0 South
M9GE 0 West


*** TODO pu_data
*** TODO received_frame_filter
*** TODO remote_control
*** TODO rx_monitor
*** TODO simulated_track
*** TODO start_dlps
*** STARTED status_checker
    - State "STARTED"    from "TODO"       [2016-04-12 Tue 00:16]

**** 확인 사항  
    - [ ] 타이머 설정 
    - [ ] 일괄 실행 
    - [X] 체크아웃 

*** DONE track_controller
    CLOSED: [2016-04-12 Tue 00:10]
    - State "STARTED"    from "TODO"       [2016-04-05 Tue 09:36]

**** 확인 사항  

    - [ ] 타이머 설정 
    - [ ] 일괄 실행 
    - [X] 체크아웃 


*** STARTED track_input
    - State "STARTED"    from "TODO"       [2016-04-02 Sat 12:44]

 - [X] 최초 실행  
*** DONE track_output
    CLOSED: [2016-04-04 Mon 16:22]
    - State "STARTED"    from "TODO"       [2016-04-04 Mon 12:37]

 - [X] 일괄 실행 

*** DONE usr_channel
    CLOSED: [2016-04-05 Tue 00:00]
    - State "STARTED"    from "TODO"       [2016-04-04 Mon 16:36]
*** TODO utility
