#+TITLE: testsc - 동적 시험 라이브러리
#+SETUPFILE: setup\theme-readtheorg-local.setup
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles/pygments.css" />
#+OPTIONS: toc:3 ^:{} num:3
#+EXPORT_EXCLUDE_TAGS: noexport

# http://orgmode.org/manual/Table-of-contents.html

* 기본 사항 
** 무엇을 하는 것인가? 
   동적 시험시 필요한 [[test_variable][테스트 변수]]를 파일로 부터 읽어 오는 라이브러리이다. 파일의
   형식은 scheme 스트립트이다. 간단한 데이터의 정의 뿐만 아니라 프로그래밍을
   통한 데이터의 생성이 가능하다.   

   [[file:concept.png]]


*** genfigure                                                     :noexport:
    #+BEGIN_SRC dot :file concept.png
      digraph {
      rankdir =LR ; 
         C [shape=box,  label="CodeScroll"] //style=filled, color="gray"
         T [shape=circle,   label="test .exe"] 
         TL [shape=doublecircle,   label="testsc library"] 
         S [shape=polygon, sides=4, skew=.3 ,  label="scheme file\ngenerage test data"] 
         C -> T
         T -> TL [dir=none] [label="linking"]
         S -> TL
      }
    #+END_SRC
    
** 장점 
*** 테스트 데이터 조합 가능
    [[test_variable][테스트 변수]]의 범위를 이용하여 데이터 조합을 생성할 수 이다. 가령 인자로
    3개의 enum 타입을 사용하는 함수의 경우 각 파라미터가 가지는 값들의 범위를
    이용하여 존재가능한 모든 파라미터 데이터 조합을 생성할 수 있다. 
*** 다수의 테스트케이스 생성
    테스트 데이터가 많을 경우 CodeScroll 이 제공하는 UI 를 통하여 데이터를
    입력하기가 불편하다. 프로그래밍을 통하여 다수의 데이터도 간편하게 생성이
    가능한다.  
*** 테스트 데이터 재활용
    Codescroll 에서 같은 [[scheme_file][scheme 파일]]을 읽어 오도록 설정하면 테스트 데이터를
    재활용할 수 있다. 구조가 같은 함수가 다수 있을 때 사용하면 편리하다. 
    라이브러리 구성이 간단하여 리눅스 타겟환경 테스트를 수행할 때도
    정적라이브러리 링크를 통하여 사용할 수 있다. 
** 단점 
   scheme 언어에 대하여 지식이 있어야 사용 가능하다. 
   [[scheme_syntax][scheme 문법 참조]]
* 사용방법 <<testsc_usage>>
    :PROPERTIES:
    :ATTACH_DIR: u:/orgdir/testsc/
    :END:
** 테스트케이스 생성 
   기존 방식 대로 CodeScroll 메뉴얼을 참고하여 테스트케이스를 생성한다. 
** *testsc* 초기화 
   다음에 나오는 C/Scheme 함수의 상세 내용은 [[reference]] 을 참조한다. 
*** testsc 헤더파일 추가 <<global_include>>
    *유닛테스트* 더블클릭 >>  *테스트 정보* >> *테스트 전역 코드*
    
    *testsc.h* 파일을 포함하도록 한다. 
    #+BEGIN_SRC cpp
    #include "testsc.h"
    #+END_SRC

    [[file:u:/orgdir/testsc/testglobalcode.png]]

*** 사용자 코드 작성 <<user_code>>
    - *유닛테스트* 더블클릭 >>  *테스트 정보* >> *사용자 코드*
      테스트스크립트를 로딩하는 부분으로써 다음과 같이 호출한다. 
    
      #+BEGIN_SRC cpp
        testsc_init(CS_TESTCASENO(), "(testsc-require mb/t-9)", "/testsc/home/");
      #+END_SRC

      [[testsc_init]] 를 호출하여 *testsc* 를 초기화 한다. 첫번째 파라미터는
      CS_TESTCASENO()으로써 *testsc* 으로 테스트번호를 전달한다. 두번째
      파라미터는 실행할 scheme 명령이다. 마지막 파라미터는 [[testsc_home][testsc 홈]]경로가 된다. 

      + 참조 : [[testsc_init]] , [[testsc_eval]] , [[testsc-require]]


    [[file:u:/orgdir/testsc/usercode.png]]

*** 호출전 코드 및 stub 코드 작성 <<before_call_code>>
**** 호출 전 코드 
     - *유닛테스트* 더블클릭 >>  *테스트 정보* >> *테스트 대상 함수* >> *호출 전 코드*
    
       테스트스크립트에서 읽은 값을 codescroll [[test_variable][테스트 변수]]에 설정한다. 

        #+BEGIN_SRC cpp
          iValue1    = testsc_ivalue("value1") ; 
          dValue2    = testsc_dvalue("value2") ; 
          strValue3  = testsc_strvalue("value3") ;
          pValue4    = (track_t*)testsc_ext_get(0) ; 
        #+END_SRC

**** stub 코드 작성 
     CodeScroll은  stub 의 동작을 제어하기 위한 변수는 생성을 하지 아니한다.
     [[scheme_file][scheme 파일]]에서 stub을 제어할 변수를 설정하고 stub 구현부에서 [[testsc_c_api][testsc C API]]
     관련 함수를 이용하여 [[test_variable][테스트 변수]]값을 가져와 사용할 수 있다. 
     테스트전역 코드에 *testsc.h* 파일이 포함되어 있기 때문에 별도의 선언 없이
     [[testsc_c_api][testsc C API]] 관련 함수를 사용할 수 있다.  

** [[scheme_file][scheme 파일]] 작성 <<make_scheme_file>>

   앞서 지정한 testsc 홈 폴더에 [[scheme_file][scheme 파일]]을 다음과 같은 순서로 작성한다. 

   1. 필요할 경우 [[scheme_file][scheme 파일]]에서 공통 정의파일을 포함한다. 테스트 대상에서
      정의한 enum 타입 및 define 된 값을 [[scheme_file][scheme 파일]]에서 사용할 수 있다. 
   
      #+BEGIN_SRC scheme
      (testsc-require icmsdefine)
      #+END_SRC

   2. [[test_variable][테스트 변수]]를 선언 한다. <<declare_test_variable>>
      scheme 의 define 을 이용하여 변수를 선언한다. 
      CodeScroll이 정의한 변수인 경우 편리를 위해 같은 이름으로 정의한다.
      CodeScroll이 정의하지 아니한 변수라도 [[scheme_file][scheme 파일]] 에서 정의하여 사용할 수
      있으며, stub 등을 작성할 때 관련 변수를 사용할 수 있다. 
      
      #+BEGIN_SRC scheme
      (define value1 TRACK_IDENTITY_FRIEND)
      (define value2 32.1234)
      (define value3 "testsctring" )
      #+END_SRC

      - [[testsc_struct][testsc 구조체]]
        테스트에 사용되는 구조체의 경우 CodeScroll 에서 [[test_variable][테스트 변수]]를 이용하여
        구조체 필드의 값을 설정한다. 대부분의 경우 변수를 이용하여 충분히 설정을
        할 수 있으나, 특이한 경우 변수만으로는 설정이 어려울 수 있다. *testsc*
        는 [[testsc_struct][testsc 구조체]] 를 이용하여 구조체 테스트 데이터를 생성할 수 있다.
        상세한 내용은 [[testsc_struct][testsc 구조체]]부분 참조.    

   3. [[scheme_test_script][scheme 파일 작성]]부분을 참조하여 *TESTCASENO* 에 따라  [[test_variable][테스트 변수]]를
      설정한다. 
      
      상세한 내용은 [[scheme_test_script][scheme 파일 작성]] 및 [[testsc_struct][testsc 구조체]]부분을 참조한다

   4. scheme.exe 를 실행하여 [[scheme_file][scheme 파일]]의 문법 오류를 확인한다. 

      [[testsc-init]] 를 이용하여 작성한 [[scheme_file][scheme 파일]]을 실행한다. 
      다음은 TESTCASENO 를 1로 설정하고 [[testsc_home][testsc 홈]] 폴더 아래 track/t-1.scm 파일을
      실행한다. 문법 오류가 있을 경우 오류가 있는 라인번호를 출력한다. 
      정상적으로 실행이 된 후 [[test_variable][테스트 변수]]를 입력하면 실행한 파일에 의해 설정된
      값을 확인할 수 있다. 
      #+BEGIN_SRC scheme
      (testsc-init 1 track/t-1 )
      #+END_SRC

** CodeScroll [[test_case][테스트 케이스]] 빌드 및 커버리지 평가 
*** 포함 파일 추가
    [[testsc_home][testsc 홈]] 을 포함 디렉토리에 추가한다. 
*** 링크 라이브러리 추가 
    [[testsc_home][testsc 홈]] 을 링크 디렉토리에 추가한다. 
    링크할 라이브러리를 추가한다. 
    #+BEGIN_QUOTE
    -L/testsc -ltestsc
    #+END_QUOTE
*** 빌드 및 [[test_case][테스트 케이스]]를 실행한다. 
    실행결과로 생성되는 커버리지를 참조하여 추가가 필요한 [[test_variable][테스트 변수]]값을
    [[scheme_file][scheme 파일]]에 설정한다.  CodeScroll 의 사용자 인터페이스를 통하여 값을
    설정하는 것 보다 빠르게 커버리지를 올릴 수 있다.  
    다음 파일은 [[test_case][테스트케이스]]가 실행하면서 출력하는 것을 저장하는 파일이다. 

    - testsc-stderr.txt : [[testsc_home][testsc 홈]] 폴더 아래 위치한다. [[test_case][테스트케이스]]가
      실행하면서 출력하는 표준에러 출력을 저장한다. 

    - testsc-stdout.txt : [[testsc_home][testsc 홈]] 폴더 아래 위치한다. [[test_case][테스트케이스]]가
      실행하면서 출력하는 표준출력 및 [[testsc_debug]] 출력을 저장한다. 

* [[scheme_file][scheme 파일]] 작성 <<scheme_test_script>>
    :PROPERTIES:
    :ATTACH_DIR: u:/orgdir/testsc/
    :END:
** scheme 파일 작성
*** 함수내의 모든 분기문을 확인한다. 

    if, switch 등의 분기문에서 사용하는 변수, 구조체 필드, 함수 리턴값 등을
    식별한다. &&(and) , ||(or) 로 조건이 중첩 되어 있는 경우 로직 연산자의 좌·우
    (operand)를 각각 따로 식별 한다. 

    CodeScroll은 테스트케이스를 생성할 때 이 항목들을 테스트입력값이나 Stub 으로
    대부분 식별한다. 


    #+BEGIN_SRC cpp
      void check_track(track_data_t* track, int value)
      {
        if(is_online() == true ){ //→ is_online() 리턴값

          switch(track->link_state){  //→ track->link_state
          case link_received :
            if( ( value > 3000 ) && (track->x_position > 10000) ){//→ value, track->x_position
              ....
            }
            else if( ( value < 700 ) || (track->x_position < 5000 ) ){//→ value, track->x_position
              ....
            }
            else {
              ....
            }
            break ; 
      
          case link_transmitted :
            break ; 
          case not_link_involved :
            break ; 
          default :
            break ; 
        }
  
      }
    #+END_SRC

*** 식별한 항목이 가져야 하는 값을 확인한다. 

    항목별로 조건들을 나열한 후 이로 부터 테스트 데이터(값의 범위)를 생성한다.
    조건으로 평가 되는 경우 true/false 가 되는 값들이며 switch의 경우
    case/default의 모든 항목 값 이다. 값의 범위 (>, <) 로 평가하는 경우 구간별로
    데이터를 포함한다. 

    - 항목별 조건 나열
    #+BEGIN_INFO 
    is_online 리턴 값    ⇰ is_online() == true 
    value                ⇰ value > 3000 ,  value < 700 
    track->x_position    ⇰ track->x_position > 10000 , track->x_position < 5000 
    track->link_state    ⇰ switch(track->link_state)
    #+END_INFO

    - 항목별 테스트 데이터 생성
 
    #+BEGIN_INFO 

    is_online 리턴 값    ⇰ (1 0 )
    value                ⇰ (4000 2000 100 )  범위 구간 마다 데이트데이터 생성
    track->x_position    ⇰ (11000 7000 3000) 범위 구간 마다 데이트데이터 생성
    track->link_state    ⇰ (link_received link_transmitted not_link_involved)

    #+END_INFO

*** 테스트 변수를 확인한다. 
    앞의 두 단계에서 확인한 값들에 대하여 변수를 정의한다. scheme 파일에서
    테스트 데이터를 정의하는데 사용한다.

    대부분 CodeScroll 이 생성하는 테스트 입력값과 같으나, CodeScroll 이 생성을 
    하지 아니한 경우에도 변수를 지정해 줄 수 있다. 이렇게 지정한 변수는 Stub
    등을 구현하는데 사용할 수 있다.
    #+BEGIN_SRC scheme
      (define value1 10)
      (define value2 3.1415926378)
      (define value3 "string 테스트 데이터")
      (anset 0 ) 
    #+END_SRC

*** scheme 파일을 작성한다. 

    [[combi]] 함수를 이용하여 모든 테스트 데이터 조합을 생성한다. 

    #+BEGIN_SRC scheme
      (combi '(1 0 ) '(4000 2000 100 ) '(11000 7000 3000) '(link_received link_transmitted not_link_involved) )
    #+END_SRC

   
    조합한 데이터를 테스트변수에 할당한다. 

    #+BEGIN_SRC scheme
      (define is_online 0 ) ;;테스트 정의 
      (define value     0 ) ;;테스트 정의
      (anset  0 
      'track.link_state 0
      'track.x_position 0) ;;테스트 admin 값 생성( id=0 )


      (feio
        1
        (lambda (x)
          (set! is_online (nth 1 x ))
          (set! value     (nth 2 x ))
          (anset 0
                 'track.x_position (nth 3 x )
                 'track.link_state (nth 4 x )))
         (combi '(1 0 ) '(4000 2000 100 ) '(11000 7000 3000) '(link_received link_transmitted not_link_involved) ))
      ;;         ↑ is_online range
      ;;                 ↑ value range
      ;;                                    ↑ track.x_position range
      ;;                                                      ↑ track.link_state range 
    #+END_SRC

** scheme 파일 디버깅 
   값이 예상과 다르거나 스크립트 로딩에 오류가 있는 것 같을 때 수행 
*** 출력 파일 확인
*** scheme 실행 
    *testsc* 홈 플더의 scheme.exe 를 실행한다. 
    [[testsc-set-testnum]] 를 이용하여 디버깅 하고자 하는 테스트 번호를 설정한다. 
    (testsc-require ac/t-1 ) 를 이용하여 테스트 스크립트를 로딩한다. 
    
    확인하고자 하는 값을 입력하면 값이 출력됨 
    #+BEGIN_SRC scheme
    (testsc-set-testnum 8 )
    (testsc-require ac/t-1 )
    ts> mas
    100
    ts> testsc
    1
    #+END_SRC

** 예제 
   
   아래의 예제는 배포파일에 포함되어 있는 CodeScroll 워크스페이스를 열어서
   확인할 수 있다. 

   *파일 >> 워크스페이스 바꾸기* 메뉴를 이용하여 예제가 있는 워크스페이스로 전환한다. 

   [[file:chworksspace.PNG][file:c:/testsc/doc/chworksspace.PNG]]

*** example1 - 파라미터 조합 
**** 테스트 대상 
     =/testsc/share/srcexample/example1.cpp= 에 대상 함수가 있다. 

     #+BEGIN_SRC c++
       int example1::get_sec_surf_ampl(const primary_surface_id_ampl_e priampl , 
                                       const secondary_surface_id_ampl_e secampl )
       {
         switch(priampl){
         case pri_surf_ampl_no_statement     : return SURPA_NO_STATEMENT ; // 세부정보 없음
         case pri_surf_ampl_line             :      //해군전단
         case pri_surf_ampl_combatant        : //함정
           switch(secampl){
           case sec_surf_ampl_no_statement   :return SURSA_NO_STATEMENT;
           case sec_surf_ampl_carrier        :return SURSA_CARRIER; // 1
           case sec_surf_ampl_destroyer      :return SURSA_DESTROYER; // 4
           case sec_surf_ampl_cruiser        :return SURSA_CRUISER; // 3
           case sec_surf_ampl_frigate        :return SURSA_FRIGATE; // 5
           case sec_surf_ampl_battleship     :return SURSA_BATTLESHIP; // 2
           default : break ;
           }
           // 다음은 실행되지 않습니다. 
           break ; 

         case pri_surf_ampl_patrol_vessel    :  // 초계함
           // 다음은 맵핑되지 않습니다. 
           //enum ESurPatrolSecondaryAmp {
           //  return SURSA_FAST_PATROL          // 3
           //};
           switch(secampl){
           case sec_surf_ampl_ASW            :return SURSA_ASW_PATROL; // 1
           case sec_surf_ampl_ASUW           :return SURSA_SURFACE_PATROL; // 2
           default : break ;
             ......
     #+END_SRC

***** 함수의 입력 파라미터 
      함수 입력으로 사용하는 두 enum 타입의 모든 조합을 [[test_variable][테스트 변수]] 로 생성하면
      100% 커버리지를 달성할 수 있다. 

      관련 enum 타입은 =/testsc/share/srcexample/example1.h= 에 정의 되어 있다. 

      *primary_surface_id_ampl_e* 8개 값, *secondary_surface_id_ampl_e* 30개
      값으로 해서 240개의 조합이 존재한다. 

**** 사용자 코드 
     *테스트 정보* >> *사용자 코드* 에서 다음 사항을 확인한다. 
     
     #+BEGIN_SRC c++
     testsc_init(CS_TESTCASENO(), "(testsc-require ex/t-1)",  "/testsc/home") ; 

     printf("printf\n") ; 
     std::cout<<"cout test"<<std::endl ; 
     #+END_SRC

     [[testsc_home][testsc 홈]] 아래 ex/t-1.scm 파일을 호출 하는 부분이다. 

**** 호출 전 코드
***** 호출 전 코드 내용 
      *테스트 정보* >> *테스트 대상 함수* << *호출 전 코드* 부분에서 CodeScroll
      이 생성한 [[test_variable][테스트 변수]]의 값을 *testsc* 에서 값을 가져 오도록 한다. 

      #+BEGIN_SRC c++
        priampl = (enum primary_surface_id_ampl_e)testsc_ivalue("priampl");
        secampl = (enum secondary_surface_id_ampl_e)testsc_ivalue("secampl");
      #+END_SRC

***** 테스트 코드 
      *테스트 코드* 에서 변경된 내용을 확인 하면 다음과 같다. 

      CodeScroll 의 [[test_case][테스트케이스]]에 추가적으로 *testsc* 를 사용하려면 호출전
      부분을 CS_TESTCASENO() 가 특정값 이상 일 때만 실행되도록 *if* 문을 사용할
      수 있다. 
      #+BEGIN_SRC c++
        /*Input*/
        priampl = (enum primary_surface_id_ampl_e)CS_INT_INPUT(enum primary_surface_id_ampl_e,"priampl");
        secampl = (enum secondary_surface_id_ampl_e)CS_INT_INPUT(enum secondary_surface_id_ampl_e,"secampl");


        #line 1 "cs_test%example1_get_sec_surf_ampl_test0%BEFORE_CALL_CODE_KEY_get_sec_surf_ampl28983194"
        priampl = (enum primary_surface_id_ampl_e)testsc_ivalue("priampl");
        secampl = (enum secondary_surface_id_ampl_e)testsc_ivalue("secampl");
        #line 40 "cs_test%example1_get_sec_surf_ampl_test0%cs_error"
      #+END_SRC

**** [[scheme_file][scheme 파일]]

     /testsc/home/ex/t-1.scm 파일 의 내용

     src_scheme{(combi (num-list 0 8) (num-list 0 30))} 을 통하여 priampl,
     secampl 각각 0~7, 0~29 의 조합을 생성한다. 

     [[foreach-tnum]]은 생성한 조합의 값을 첫번째 파라미터 이후의 테스트케이스에
     대하여 순서대로 lambda 함수에 전달한다

     #+BEGIN_SRC scheme
       (define priampl 0)
       (define secampl 0)

       (foreach-tnum
        1                                      ; testcase 시작값
        (lambda (x)                            ; testcase 번호에서 testcase 시작값을 뺀 번째 조합 값을 파라미터로 전달한다. 
          (set! priampl (nth 0 x))             ; 조합값의 첫번째 값은 priampl
          (set! secampl (nth 1 x)))            ; 조함값의 두번째 값은 secampl
        (combi (num-list 0 8) (num-list 0 30)))

       ;;; combi (num-list 0 8 ) (num-list 0 30 ) 
       ;;; -> ((0 0 ) (0 1 ) (0 2 )... (0 29) (1 0 ) (1 1 ) ...)
       ;;;     ↑ testcase 시작 값과 같은 경우 lambda 함수로 전달
       ;;;            ↑ testcase 시작 값보다 1 클 경우 lambda 함수로 전달

       (case (testsc-get-testnum)              ; C 의 switch 문에 해당 - testcase 번호
         ((241)                                ; C 의 case 문에 해당 - testcase 번호가 241 일 경우  
          (set! priampl -1)))                  ; priampl 을 -1 로 설정한다. 
     #+END_SRC
     
**** 실행 
     [[test_case][테스트케이스]]실행을 하여 커버리지 100% 가 되는 것을 확인 한다. 
     
     [[testsc_home][testsc 홈]] 아래 testsc-stdout.txt 파일을 열어 보면 다음과 같은 로그를 확인
     할 수 있다. 

     #+BEGIN_QUOTE
      testsc-require /testsc/home/util.scm
      testsc-require /testsc/home/testsc.scm
      testsc-require /testsc/home/testsc-ext.scm
      testsc-require /testsc/home/ex/t-1.scm
      foreach-tnum next testnum is  241             → t-1.scm 에 있는 foreach-tnum  다음의 테스트번호가 241임을 알려줌 
      testsc initalize done                         → testsc_init 함수가 끝나는 시점
      printf                                        → 테스트코드(사용자코드) 표준출력 redirection 
      cout test                                     → 테스트코드(사용자코드) 표준출력 redirection 
      testsc_ivalue priampl is 7                    → 테스트코드(호출전 코드)에서 testsc_ivalue 의 값
      testsc_ivalue secampl is 1                    → 테스트코드(호출전 코드)에서 testsc_ivalue 의 값
     #+END_QUOTE


     ex/t-1.scm 파일에서 괄호를 하나 추가 하고 실행하면 다음과 같은 에러 로그를
     확인할 수 있다.   

     #+BEGIN_QUOTE
     
     #+END_QUOTE

*** 예제 2 - enum 변수 확인 
*** 예제 3 - filter check 
*** 예제 4 - 구조체 예제
*** 예제 5 - stub 활용 
* testsc 구조체  <<testsc_struct>>
  [[scheme_file][scheme 파일]]을 통하여 구조체를 정의할 수 있다. [[test_variable][테스트 변수]]를 사용하여 구조체
  필드를 각각 설정하기 어려운 경우 사용한다. 사용되는 구조체의 필드가 다수일 경우,
  스텁함수에서 구조체에 대한 포인터를 리턴하는 경우, 사용되는 구조체가 다수인
  경우 등이 해당한다. 

  추가적인 C 구현이 필요하기 때문에 
  데이터가 필요할 경우 사용한다. 추가적으로 C 함수를 구현해야 하는데, 구조체의
  필드별로 테스트변수를 만들어서 설정하는방식과 비교하여 한번 구현해 두면 유리할 경우 추가 구현하여 사용한다. 

C 함수 추가
  구현이 필요한 부분으로써 관련 구조체가 빈번히 사용될 경우 구현을 하면 

C 구현이
  필요하기 때문에 내부에서 자주 사용하는 구조체에 대하여 구현을 사고 


GFE 로 부터 받는 메시지등을 구현하는데 사용할 수 있다. 

      [[test_variable][테스트 변수]]를 활용해서 구조체의 필드에 값을 설정할 수 있다. 대부분의 경우
      
      [[testsc_struct][testsc 구조체]]는 테스트에 사용되는 구조체 생성을 위해 *testsc* 가
      내부적으로 사용하는 구조체를 의미한다. 

      다음은 식별자 0 으로 _track.TMSIndex 필드 값이 0 _track.identity 가 FRIEND
      구조체를 생성한다.  

      [[testsc_struct][testsc 구조체]]에 대한 상세한 내용은 [[testsc_struct][testsc 구조체]]부분 참조 
      #+BEGIN_SRC scheme
      (testsc-stset 0 
                      '_track.TMSIndex 10
                      '_track.identit  FRIEND )
      #+END_SRC

** 구조체 테스트 데이터 생성 
   확장 모듈을 이용하여 구조체 테스트 데이터를 생성할 수 있다. 
   [[testsc_ext_get]] 을 이용하여 scheme 파일에서 생성한 구조체를 가져 온다. 

** 빌드 방법 
   build.bat 파일을 이용하여 빌드를 수행한다. 

   scheme.exe 파일을 생성하기 위해서는 -DSTANDALONE=1 을 컴파일러로 전달해야 한다. 

   libtestsc.a 파일을 생성하기 위해서는 -DSTANDALONE=0 을 컴파일러로 전달해야 한다.  
   
* Best Practice 
** 비관리 코드 활용 


   [[test_case][테스트케이스]]생성후 바로 비관리로 전환하며 직접 입력할 수 도 있다. 

   비관리로 전환을 하였을 경우 테스트케이스 파일을 직접 편집할 수 있다. 비관리
   코드로 전환하면 CodeScroll 없이 작업을 할 수 있어 라이센스를 절약할 수 있다. 


   CodeScroll 테스트케이스 생성 및 일괄 빌드 후 비관리 코드 전환을 수행하고
   테스트를 CodeScroll 없이 테스트를 편집할 수 있다. 결과적으로 CodeScroll
   라이센스를 절약할 수 있다.  
*** 일괄 비관리 코드 전환
    CodeScroll 를 종료한 상태에서 프로젝트폴더내의 *.csp* 파일을 찾은 후
    sqlite3 실행 파일을 이용하여 다음과 같이 수행한다. 

    수행시 해당 .cpp 파일의 모든 함수가 비관리 코드로 전환 된다. 
     
    #+BEGIN_SRC shell
    .\sqlite3 c:\codescroll\testsc1\.csdata\testsfile.csp < unmanage.sql
    #+END_SRC


    다음은 unmanage.sql 의 내용이다. 

    #+BEGIN_SRC sql
      update UtTest set isManaged = 0 ; 
    #+END_SRC
     
*** unittest 내부의 c 파일 편집
    비관리 코드 전환이 되었을 때만 직접 편집을 하여야 한다. 안된 상태서
    편집하는 경우 관련 사항을 읽어버릴 수 있다. 
    - USER_CODE_GLOBAL_KEY 부분을 찾아서 [[global_include][관련 헤더파일 include]] 부분을 직접 편집한다. 
    - User code start 부분을 찾아서 [[user_code][사용자 코드 작성]] 부분을 직접 편집한다.
    - 테스트 대상 함수 호출 전에 [[before_call_code][호출전 코드 및 stub 코드 작성]] 부분을 직접 편집한다.  

** CodeScroll 의 테스트데이터와 같이 사용
   *CS_TESTCASENO()* 를 이용하여 관련 부분이 실행이 아니되게 할 수 있다. 다음과
   같이 실행하며 10 보다 큰 테스트케이스에 대해서만 [[scheme_file][scheme 파일]]로 부터 값을 읽어
   온다.  

    #+BEGIN_SRC cpp

      if(CS_TESTCASENO() > 10){
        iValue1    = testsc_ivalue("value1") ; 
        dValue2    = testsc_dvalue("value2") ; 
        strValue3  = testsc_strvalue("value3") ;
        pValue4    = (track_t*)testsc_ext_get(0) ; 
      }
    #+END_SRC

** testsc 확장 모듈 
   C 를 이용하여 확장 할 수 있다. C 확장을 불필요하게 생성하는 것을 지양하고
   최대한 scheme 파일을 활용할 수 있도록 한다. 구조체에 대한 확장 정도만 구현을
   하여도 충분하다. 

*** 구조체 테스트 데이터 생성 
    확장 모듈을 이용하여 구조체 테스트 데이터를 생성할 수 있다. 
    [[testsc_ext_get]] 을 이용하여 scheme 파일에서 생성한 구조체를 가져 온다. 

*** 테스트 데이터를 파일에서 가져오게 한다. 
**** 컴파일 없이 테스트 수행을 할 수 있다. 
*** 테스트 데이터를 프로그래밍 할 수 있게 한다. 
    테스트 데이터에 대한 프로그래밍을 통하여 커버리지를 높일 수 있는 데이터를
    생성할 수 있다.
*** 라이브러리를 활용한다. 
    STUB 을 중복적으로 생성할 필요 없이 재사용 할 수 있다. 
**** embedded language 활용
***** scheme
      문법이 간단하여 구현이 용이함. 
****** 구현 - tinyscheme
       5천 라인 정도의 C 파일로 language 가 구현 되어 있음. 
       codescroll에서 사용하는 컴파일러만으로 컴파일 가능. 추가 도구 등이 필요
       없음. 
** 정의 파일 활용 
*** enum 타입 및 공통 상수 값 정의 
    [[scheme_file][scheme 파일]] 처음 실행 할 때 *(testsc-require icmsdefine)* 를 호출하여 관련 값을 가져올
    수 있다. 각 타입의 값을 찾을 필요 없이 그대로 사용할 수 있다. 

    icmsdefine.scm 파일이 공통으로 사용하는 부분이 정의되어 있음. 필요할 경우
    타입를 추가 할 수 있다. 

    두번 정의가 될 경우 뒤에 나오는 값으로 설정이 된다. 

** testsc 수정시 
   정적 라이브러리이기 때문에 [[test_case][테스트케이스]]재빌드 필요하다. 

** 표준 출력 redirection 
   라이브러리가 표준 출력을 파일로 redirection 해준다 코드가 실행하면서
   출력하는 사항을 파일로 확인할 수 있다. 

   
* Reference <<reference>>
** C API - <<testsc_c_api>>
   CodeScroll 에서 스텁등을 작성할 때 사용한다. 
*** testsc.cpp
    [[test_variable][테스트 변수]]를 처리하는 함수
**** 함수 
***** long testsc_ivalue(const char* name)  <<testsc_ivalue>>
      #+BEGIN_SRC 

      #+END_SRC
***** double testsc_dvalue(const char* name)  <<testsc_dvalue>>
***** char* testsc_strvalue(const char* name)  <<testsc_strvalue>>
***** void testsc_eval(const char *cmd)  <<testsc_eval>>
      [[testsc_init]] 에서 초기화 하면서 scheme 을 실행하는 것에 더하여 추가적으로
      다른 scheme 명령을 실행고 싶을 때 사용한다. [[testsc-require]] 명령을 이용하여
      다른 파일을 불러 올 수 있다. 

 [[scheme_file][scheme 파일]]를 불어오는 것에 추가적으로 다른 파일을 불러
      오고 싶을 사용한다. 
    - scheme 파일 추가 실행 
      다음과 같이 수행하면 관련 scheme 파일을
    #+BEGIN_SRC cpp
      testsc_eval( "(testsc-require mb/t-9)") ;
    #+END_SRC

***** void testsc_init(int testnum, const char *cmd, const char *homepath = 0 )  <<testsc_init>>



      [[testsc_init]] 를 호출하여 *testsc* 를 초기화 한다. 첫번째 파라미터는
      CS_TESTCASENO() 으로써 테스트번호를 전달한다. 두번째 파라미터는 실행할
      scheme 명령이다. [[testsc-require]] 를 호출하여 [[scheme_file][scheme 파일]]을 읽어 올 수 있다.
      마지막 파라미터는 *testsc* 의 HOME 경로가 된다. [[testsc-require]] 는 홈
      경로아래에서 [[scheme_file][scheme 파일]] 을 불러온다. 경로를 파라미터로 넘기지 아니할 경우
      프로젝트가 있는 드라이브의 =/testsc/home= 폴더가 홈이 된다. (C 드라이브에
      프로젝트 폴더가 있을 경우 =c:\testsc\home= 폴더, 리눅스의 경우
      =/testsc/home= )       



***** void testsc_debug(const char*format ...)  <<testsc_debug>>

*** testsc_ext.cpp
**** 함수 
***** int testsc_ext_length( void ) <<testsc_ext_length>>
***** void testsc_ext_erase(int index ) <<testsc_ext_erase>>
***** char* testsc_ext_get( int i )  <<testsc_ext_get>>
****** 구현 방법 
***** pop_args 

** scheme API - <<testsc_scheme_api>>
*** util.scm 
**** 변수 
***** *testsc-home*  <<*testsc-home*>> 
      - 목적 : 스크립트 파일 위치 
      - 방향 : 
      - 사용법 
        testsc-debug 를 이용하여 경로를 확인한다. 
       
        #+BEGIN_SRC scheme
        (testsc-debug *testsc-home*)
        #+END_SRC

**** 함수 
***** (define-macro (testsc-require x) ...) <<testsc-require>>


    [[testsc-require]] 의 파라미터는 불러오고자 하는 [[scheme_file][scheme 파일]]이다. (testsc-require
    mb/t-9) 은 홈 폴더 아래의 *mb/t-9.scm* 파일을 호출한다. 경로명에 공백이
    있어서는 아니되고 파일의 확장자인 *.scm* 은 생략해야 한다. 

    경로명은 다음과 같는 명명 규칙을 사용한다. 단순한 convention이며 따르지
    아니하여도 상관없음. 기억하기 쉽고 짧을 수록 유리

    #+BEGIN_QUOTE
      - 폴더명 : 테스트하고자 하는 .cpp 파일을 나타내는 약어
      - t-testname.scm : 테스트케이스(함수별) 를 나타내는 약어. *t-* 으로 시작
        하도록 한다. 
    #+END_QUOTE
***** (define (t-offset start) ...) <<t-offset>> 
      (define (t-offset start) (- (testsc-get-testnum) start))

***** (define (for-each-index-offset offset proc  . args ) ...) <<for-each-index-offset>>
      - 목적 : 테스트케이스별 값을 설정한다. 
      - 사용법 : 테이스케이스별로 순차적으로 값을 설정하고자 할 때 사용한다. 
        #+BEGIN_SRC scheme
        (define testsc 0 )
        (define order 0 )
        (for-each-index-offset
          1
          (lambda (x)
            (set! testsc 1 )
            (set! order x)
            )
            system_types-assume_cntrl
            system_types-control_and_engage
            system_types-return_to_base
            system_types-transfer_cntrl
            system_types-launch_heli
            system_types-request_cntrl
            system_types-cancel_handover  
            -1
          )

        #+END_SRC
      - 입력 파라미터 
        + offset : 값 설정을 시작할 테스트케이스 번호
        + proc   : 값 설정을 수행할 함수 
        + args   : 테스트 값 

***** (define (feio offset proc args ) ...) <<feio>>
      - 목적 : 테스트케이스별 값을 설정한다. 
      - 사용법 : 테이스케이스별로 순차적으로 값을 설정하고자 할 때 사용한다. 
                 [[for-each-index-offset]] 와 비교하여 args 부분에 리스트가 올 수
                 있다. 
        #+BEGIN_SRC scheme

          (define i_enStatus 0)
          (define m_bEnableCallback 0)
          (define i_pchData_0 0)
          (define i_pchData_1 0)

          (feio
           1
           (lambda (x)
             (set! i_enStatus        (nth 0 x))
             (set! m_bEnableCallback (nth 1 x))
             (set! i_pchData_0       (nth 2 x))
             (set! i_pchData_1       (nth 3 x)))

           (combi '(11 12) '(1) '(4 5 ) '(1 0 )))


        #+END_SRC

***** (define (combi . args)...) <<combi>>
      - 목적 : 테스트 데이터 생성(combination)
      - 사용법 : 

        #+BEGIN_SRC scheme
        (combi '(a b ) '(1 2 ))
        #+END_SRC

        #+RESULT :
        '((a 1) (a 2) (b 1) (b 2))
***** (define (nth n l) ...)
      - 목적 : 리스트에서 n 번째 항목을 리턴한다. 
      - 사용법 : 리스트에서 값을 가져오고자 할 때 사용한다. 

        #+BEGIN_SRC scheme
        (nth 3 '(zero one two three four))
        #+END_SRC

        #+RESULT :
        three

      - 입력 파라미터 
        + n : 리스트에서 가져오고자 하는 인덱스( 0 부터 시작 ) 
        + l : 리스트 
***** (define (num-list start end  ) ...) <<num-list>>

      - 프로토타입 : (define (num-list start end  ) ...)
      - 목적 : 숫자 리스트를 리턴한다. 
      - 사용법 : 

        #+BEGIN_SRC scheme
        (num-list 1 10)
        #+END_SRC

        #+RESULT :
        '(1 2 3 4 5 6 7 8 9 )

      - 입력 파라미터 
        + start : 시작 값(포함)
        + end : 종료 값(불포함)

***** (define-macro (testsc-init x  initcmd) ...) <<testsc-init>>
***** populate
      구현 필요. 
**** test_sc.c 
*****  pointer foreign_testsc_set_testnum(scheme* sc, pointer args) <<foreign_testsc_set_testnum>> <<testsc-set-testnum>>

** 추가 C excention 구현 
   C 를 이용하여 추가적인 기능을 구현할 수 있다.

   어떻게 구현 하는지 설명 할 수 있다.

*** 구조체 테스트 데이터 생성 
    
* scheme 문법 <<scheme_syntax>>

** scheme 파일 에디터 
** 15분 만에 scheme 배우기
   #+BEGIN_SRC scheme
     ;; This gives an introduction to Scheme in 15 minutes
     ;;
     ;; First make sure you read this text by Peter Norvig:
     ;; http://norvig.com/21-days.html
     ;;
     ;; Then install GNU Guile
     ;; NOTE: I won't encourage using Racket but if you really want,
     ;;       I still give you some hints in this tutorial. But the
     ;;       tutorial will base on Guile and RnRs.
     ;;
     ;; openSUSE: zypper install guile
     ;; Debian: apt-get install guile-2.0 (or see your distro instructions)
     ;; MacOSX: Building Guile 2.0 on the Mac
     ;;         http://irrealblog.blogspot.hk/2011/03/building-guile-2.html
     ;; Windows try web: http://repl.it/languages/Scheme
     ;;
     ;; More general information can be found at:
     ;; http://www.gnu.org/software/guile

     ;; Important warning:
     ;;
     ;; Going through this tutorial won't damage your computer unless
     ;; you get so angry that you throw it on the floor.  In that case,
     ;; I hereby decline any responsability.  Have fun!

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; 
     ;; Fire up Scheme:
     ;; Type 'guile' for GNU Guile
     ;; Or just use the browser for web version
     ;;
     ;; Now look at the prompt:

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;;
     ;; Semi-colons start comments anywhere on a line.
     ;;
     ;; Scheme programs are made of symbolic expressions (s-exps):
     (+ 2 2)

     ;; This symbolic expression reads as "Add 2 to 2".

     ;; Sexps are enclosed into parentheses, possibly nested:
     (+ 2 (+ 1 1))

     ;; A symbolic expression contains atoms or other symbolic
     ;; expressions.  In the above examples, 1 and 2 are atoms,
     ;; (+ 2 (+ 1 1)) and (+ 1 1) are symbolic expressions.

     (+ 3 (+ 1 2))
     ;; => 6

     ;; `set!' stores a value into a variable:
     ;; Please define my-name first, or you can't assign it.
     (define my-name "unknown")
     (set! my-name "NalaGinrut")

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; 1. Primitive Datatypes and Operators
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

     ;;; Numbers
     9999999999999999999999 ; integers
     #b111                  ; binary => 7
     #o111                  ; octal => 73
     #x111                  ; hexadecimal => 273
     3.14                   ; reals
     6.02e+23
     1/2                    ; rationals
     1+2i                   ; complex numbers

     ;; Function application is written (f x y z ...)
     ;; where f is a function and x, y, z, ... are operands
     ;; If you want to create a literal list of data, use ' to stop it from
     ;; being evaluated
     '(+ 1 2) ; => (+ 1 2)
     ;; Now, some arithmetic operations
     (+ 1 1)  ; => 2
     (- 8 1)  ; => 7
     (* 10 2) ; => 20
     (expt 2 3) ; => 8
     (quotient 5 2) ; => 2
     (remainder 5 2) ; => 1
     (/ 35 5) ; => 7
     (/ 1 3) ; => 1/3
     (exact->inexact 1/3) ; => 0.3333333333333333
     (+ 1+2i  2-3i) ; => 3-1i

     ;;; Booleans
     #t ; for true
     #f ; for false -- any value other than #f is true
     (not #t) ; => #f
     (and 0 #f (error "doesn't get here")) ; => #f
     (or #f 0 (error "doesn't get here"))  ; => 0

     ;;; Characters
     ;; According to RnRs, characters only have two notations:
     ;; #\ and #\x
     ;; Racket support #\u, but it's never Scheme.
     #\A ; => #\A
     #\λ ; => #\λ
     #\x03BB ; => #\λ

     ;;; Strings are fixed-length array of characters.
     "Hello, world!"
     "Benjamin \"Bugsy\" Siegel"   ; backslash is an escaping character
     "Foo\tbar\x21\a\r\n" ; includes C escapes (only support hex)
     ;; try to print the above string
     ;; Printing is pretty easy
     (display "I'm Guile. Nice to meet you!\n")
     ;; and unicode escapes
     "\u004B" ; => K

     ;; Strings can be added too!
     (string-append "Hello " "world!") ; => "Hello world!"

     ;; A string can be treated like a list of characters
     (string-ref "Apple" 0) ; => #\A

     ;; format can be used to format strings:
     (format #t "~a can be ~a" "strings" "formatted")
     ;; ==> print "strings can be formatted" on screen
     (define str (format #f "~a can be ~a" "strings" "formatted"))
     ;; str was assigned to "strings can be formatted"

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; 2. Variables
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; You can create a variable using define
     ;; a variable name can use any character except: ()[]{}",'`;#|\
     (define some-var 5)
     some-var ; => 5

     ;; Accessing a previously unassigned variable is an exception
                                             ; x ; => x: undefined ...

     ;; Local binding: `me' is bound to "Bob" only within the (let ...)
     (let ((me "Bob"))
       "Alice"
       me) 
     ;; => "Bob"

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; 3. Structs and Collections
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

     ;; Record Type (Skip this chapter if you're trying web version
     (use-modules (srfi srfi-9))
     (define-record-type dog 
       (make-dog name breed age)
       dog?
       (name dog-name)
       (breed dog-breed)
       (age dog-age))
     (define my-pet
       (make-dog "lassie" "collie" 5))
     my-pet ; => #<dog>
     (dog? my-pet) ; => #t
     (dog-name my-pet) ; => "lassie"

     ;;; Pairs (immutable)
     ;; `cons' constructs pairs, `car' and `cdr' extract the first
     ;; and second elements
     (cons 1 2) ; => '(1 . 2)
     (car (cons 1 2)) ; => 1
     (cdr (cons 1 2)) ; => 2

     ;;; Lists

     ;; Lists are linked-list data structures, made of `cons' pairs and end
     ;; with a '() to mark the end of the list
     (cons 1 (cons 2 (cons 3 '()))) ; => '(1 2 3)
     ;; `list' is a convenience variadic constructor for lists
     (list 1 2 3) ; => '(1 2 3)
     ;; and a quote can also be used for a literal list value
     '(1 2 3) ; => '(1 2 3)

     ;; Can still use `cons' to add an item to the beginning of a list
     (cons 4 '(1 2 3)) ; => '(4 1 2 3)

     ;; Use `append' to add lists together
     (append '(1 2) '(3 4)) ; => '(1 2 3 4)

     ;; Lists are a very basic type, so there is a *lot* of functionality for
     ;; them, a few examples:
     ;; For Racket users:
     (map add1 '(1 2 3))          ; => '(2 3 4)
     ;; For Guile users:
     (map 1+ '(1 2 3))	     ; => '(2 3 4)
     ;; add1 or 1+ is not a standard primitive, so it depends on implementations.

     (map + '(1 2 3) '(10 20 30)) ; => '(11 22 33)

     ;; filter/count/take/drop are dwell in SRFI-1, so you have to load it first.
     ;; For Racket users:
     (require srfi/1)
     ;; For Guile users:
     (use-modules (srfi srfi-1))

     (filter even? '(1 2 3 4))    ; => '(2 4)
     (count even? '(1 2 3 4))     ; => 2
     (take '(1 2 3 4) 2)          ; => '(1 2)
     (drop '(1 2 3 4) 2)          ; => '(3 4)

     ;;; Vectors

     ;; Vectors are fixed-length arrays
     #(1 2 3) ; => '#(1 2 3)

     ;; Use `vector-append' to add vectors together
     ;; NOTE: vector-append is in SRFI-43 which is not supported in Guile-2.0.9
     ;;       or earlier. And it may not be added in Guile-2.0.10.
     ;;       But it's proposed in R7RS, and there's a r7rs branch in Guile upstream.
     ;;       If your Guile doesn't support vector-append, please skip this step.
     (vector-append #(1 2 3) #(4 5 6)) ; => #(1 2 3 4 5 6)

     ;;; Hashes

     ;; Create mutable hash table
     ;; For GNU Guile
     (define m (make-hash-table))
     (hash-set! m 'a 1)
     (hash-set! m 'b 2)
     (hash-set! m 'c 3)

     ;; Retrieve a value
     (hash-ref m 'a) ; => 1

     ;; Retrieving a non-present value is an exception
     (hash-ref m 'd) 
     ;; => #f 

     ;; You can provide a default value for missing keys
     (hash-ref m 'd 0)
     ;; => 0

     ;; Use `hash-remove' to remove keys (functional too)
     (hash-remove! m 'a) ; => ((b . 2) (c . 3))

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; 3. Functions
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

     ;; Use `lambda' to create functions.
     ;; A function always returns the value of its last expression
     (lambda () "Hello World") ; => #<procedure>

     ;; Use parens to call all functions, including a lambda expression
     ((lambda () "Hello World")) ; => "Hello World"
     ((lambda (x) (+ x x)) 5)      ; => 10

     ;; Assign a function to a var
     (define hello-world (lambda () "Hello World"))
     (hello-world) ; => "Hello World"

     ;; You can shorten this using the function definition syntatcic sugar:
     (define (hello-world2) "Hello World")
     (hello-world2) ; => "Hello World"

     ;; The () in the above is the list of arguments for the function
     (define hello
       (lambda (name)
         (string-append "Hello " name)))
     (hello "Steve") ; => "Hello Steve"
     ;; ... or equivalently, using a sugared definition:
     (define (hello2 name)
       (string-append "Hello " name))

     ;; You can have multi-variadic functions too, using `case-lambda'
     (define hello3
       (case-lambda
         (() "Hello World")
         ((name) (string-append "Hello " name))))
     (hello3 "Jake") ; => "Hello Jake"
     (hello3) ; => "Hello World"
     ;; ... or specify optional arguments with a default value expression
     (define* (hello4 #:key (name "World"))
       (string-append "Hello " name))

     ;; Functions can pack extra arguments up in a list
     (define (count-args . args)
       (format #t "You passed ~a args: ~a" (length args) args))
     (count-args 1 2 3) ; => "You passed 3 args: (1 2 3)"
     ;; ... or with the unsugared `lambda' form:
     (define count-args2
       (lambda args
         (format #t "You passed ~a args: ~a" (length args) args)))

     ;; You can mix regular and packed arguments
     (define (hello-count name . args)
       (format #t "Hello ~a, you passed ~a extra args" name (length args)))
     (hello-count "Finn" 1 2 3)
                                             ; => "Hello Finn, you passed 3 extra args"
     ;; ... unsugared:
     (define hello-count2
       (lambda (name . args)
         (format #t "Hello ~a, you passed ~a extra args" name (length args))))

     ;; And with keywords
     ;; the keywords are those like this #:its-name, sometimes you may see
     ;; :its-name without '#' in certain Scheme implementation.
     ;; NOTE: keywords is not in any Scheme standards like RnRs.
     ;;       But mainstream Scheme implementation often contains it. 
     ;;	 This truth also means that different implementation may has
     ;;	 different result.
     ;;       The code below will follow Guile situation.
     (define* (hello #:key (name "World") (greeting "Hello") . args)
       (format #t "~a ~a, ~a extra args~%" greeting name (length args)))
     ;; 'define*' is similar with 'define', but you may use it for defining
     ;; optional args or using keyword to specify the value to specified argument.
     (hello)                 ; => "Hello World, 0 extra args"
     (hello 1 2 3)           ; => "Hello World, 3 extra args"
     (hello #:greeting "Hi") ; => "Hi World, 2 extra args"
     ;; NOTE: In Guile, all the keyword-value pairs are countered as the rest args.
     ;;       It means 'args' here will be (#:greeting "Hi"), so its length is 2.
     ;;       If you are in Racket, it's different, so the result will be 0.
     ;;       Because it's not defined in RnRs, so it's implementation specific.
     (hello #:name "Finn" #:greeting "Hey") ; => "Hey Finn, 4 extra args"
     (hello 1 2 3 #:greeting "Hi" #:name "Finn" 4 5 6) ; => "Hi Finn, 10 extra args"

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; 4. Equality
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

     ;; for numbers use `='
     (= 3 3.0) ; => #t
     (= 2 1) ; => #f

     ;; for characters use `char=?'
     (char=? #\c #\c) ; => #t

     ;; for object identity use `eq?'
     ;; WARNING: don't use `eq?' on numbers and characters, the reason is very simple:
     ;;          because RnRs treat this rule as undefined! 
     ;;(eq? 3 3) ; => Wrong! it's undefined! So it depends on implementation!
     ;; No matter if you got #t from above, it's a wrong usage!!!
     ;; Should use (= 3 3) or (eqv? 3 3)

     (eq? (list 3) (list 3)) ; => #f
     ;; Why it's #f? Because comparison between objects depends on their head-pointers.
     ;; These two lists are different objects, and they have different head-pointers.

     (eq? 'a 'a) ; => #t
     ;; Symbols are the typical objects to compare with their head-pointers

     ;; eqv?
     ;; The difference between `eqv?' and `eq':
     ;; You can compare numbers and characters with `eqv?'
     ;; When you use `eqv?' for any objects other than numbers&characters, it's the
     ;; same with `eq?'.
     (eqv? 3 3)     ; => #t
     (eqv? #\c #\c) ; => #t
     (eqv? 'a 'a)   ; => #t

     ;; for collections use `equal?'
     ;; `equal?' will compare all the values in a collections type like record or list.
     ;; You can compare any objects with `equal?' safely, but inefficiency.
     (equal? (list 'a 'b) (list 'a 'b)) ; => #t
     (equal? (list 'a 'b) (list 'b 'a)) ; => #f

     ;; Choosing proper equal pred for you code, is one of the art in Scheme programming!

     (eqv? "abcd" "abcd") ; => unspecified
     ;; Obviously, strings are collections type, so...it's your EXECISE now!

     ;; Another EXECISE, what's the proper 'equal-pred' for functions?
     (what-to-use? (lambda (x) (1+ x)) (lambda (x) (1+ x)))

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; 5. Control Flow
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

     ;;; Conditionals

     (if #t               ; test expression
         "this is true"   ; then expression
         "this is false") ; else expression
                                             ; => "this is true"

     ;; In conditionals, all non-#f values are treated as true
     (member 'Groucho '(Harpo Groucho Zeppo)) ; => '(Groucho Zeppo)
     (if (member 'Groucho '(Harpo Groucho Zeppo))
         'yep
         'nope)
                                             ; => 'yep

     ;; `cond' chains a series of tests to select a result
     (cond ((> 2 2) (error "wrong!"))
           ((< 2 2) (error "wrong again!"))
           (else 'ok)) ; => 'ok

     ;;; Pattern Matching
     ;; For Racket users:
     (require racket/match) ; use match module
     (define (fizzbuzz? n)
       (match (list (remainder n 3) (remainder n 5))
         ((list 0 0) 'fizzbuzz)
         ((list 0 _) 'fizz)
         ((list _ 0) 'buzz)
         (else #f)))

     ;; For Guile users:
     (use-modules (ice-9 match)) ; use match module
     (define (fizzbuzz? n)
       (match (list (remainder n 3) (remainder n 5))
         ((0 0) 'fizzbuzz)
         ((0 _) 'fizz)
         ((_ 0) 'buzz)
         (else #f)))

     (fizzbuzz? 15) ; => 'fizzbuzz
     (fizzbuzz? 37) ; => #f

     ;;; Loops

     ;; Looping can be done through (tail-) recursion
     (define (lp i)
       (when (< i 10)
         (format #t "i=~a\n" i)
         (lp (1+ i))))
     (lp 5) ; => i=5, i=6, ...

     ;; Similarly, with a named let
     (let lp ((i 0))
       (when (< i 10)
         (format #t "i=~a\n" i)
         (lp (1+ i)))) ; => i=0, i=1, ...

     ;; how to get a range? just like range(0, 9)?
     ;; the original 'iota' only accept one para
     (iota 10) ; ==> (0 1 2 3 4 5 6 7 8 9)
     ;; the 'iota' in srfi-1 was extended 
     (use-modules (srfi srfi-1))
     ;; #<procedure iota (count #:optional start step)>
     (iota 5 10) ; => (10 11 12 13 14) 
     ;; means from 10 count 5 times, each step +1 (plus one is default)
     (iota 5 10 2) ; => (10 12 14 16 18)
     ;; from 10 count 5 times, each step +2
     ;; If you need a Python like range(5, 10) ==> (5 6 7 8 9), try:
     (define (range from to) (map (lambda (x) (+ from x)) (iota (- to from))))
     ;; EXECISE: you may find this 'range' implementation is not so good,
     ;;          please optimize it if you can.
     (range 5 10) ; => (5 6 7 8 9)

     ;; how to do iteration?
     (for-each display '(1 2 3 4 5))
     ;; => 12345
     (for-each (lambda (i) (format #t "i=~a\n" i))
               (iota 10)) ; => i=0, i=1, ...
     (for-each (lambda (i) (format #t "i=~a\n" i))
               (range 5 10)) ; => i=5, i=6, ...

     ;;; Iteration Over Other Sequences
     ;; `for' allows iteration over many other kinds of sequences:
     ;; lists, vectors, strings, sets, hash tables, etc...
     (for-each display '(l i s t))
     ;; => list
     (define vector-for-each (@ (rnrs) vector-for-each))
     ;; export vector-for-each from rnrs only
     (vector-for-each display #(v e c t o r))
     ;; => vector
     (string-for-each display "string")
     ;; => string
     ;;; More Iterations
     (do ((i 10 (1+ i)) (j '(x y z) (cdr j))) 
         ((null? j)) ; if j is '(), just end the loop
       (format #t "~a:~a " i (car j)))
                                             ; => 0:x 1:y 2:z

     ;;; Exceptions

     ;; To catch exceptions, use the 'catch' form
     (catch 'my-error 
       (lambda () (throw 'my-error))
       (lambda e (display "oh~my error!\n")))
                                             ; => oh~my error!

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; 6. Mutation
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

     ;; Use `set!' to assign a new value to an existing variable
     (define n 5)
     (set! n (1+ n))
     n ; => 6

     ;; Use fluid for explicitly mutable values
     (define n* (make-fluid 5))
     (fluid-set! n* (1+ (fluid-ref n*)))
     (fluid-ref n*) ; => 6

     ;; Many Guile datatypes are immutable (pairs, lists, etc), some come in
     ;; both mutable and immutable flavors (strings, vectors, hash tables,
     ;; etc...)

     ;; Use `vector' or `make-vector' to create mutable vectors
     (define vec (vector 2 2 3 4))
     (define wall (make-vector 100 'bottle-of-beer))
     ;; Use vector-set! to update a slot
     (vector-set! vec 0 1)
     (vector-set! wall 99 'down)
     vec ; => #(1 2 3 4)

     ;; Create an empty mutable hash table and manipulate it
     (define m3 (make-hash-table))
     (hash-set! m3 'a 1)
     (hash-set! m3 'b 2)
     (hash-set! m3 'c 3)
     (hash-ref m3 'a)   ; => 1
     (hash-ref m3 'd 0) ; => 0
     (hash-remove! m3 'a)

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; 7. Modules
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

     ;; Modules let you organize code into multiple files and reusable
     ;; libraries; Make sure put all the module code in one file, since 
     ;; the modules split as files. And the module name should be same 
     ;; with the filename, say, module named (my-cake) is 'my-cake.scm',
     ;; and module named (mods my-cake) is 'mods/my-cake.scm',
     ;; (mods submods my-cake) ==> 'mods/submods/my-cake.scm'.
     ;; ---begin my-cake.scm---
     (define-module (my-cake) ; define a `cake' module based on racket/base
       #:use-module (ice-9 format) ; the pre-requisition of current module
       #:export (print-cake)) ; function exported by the module

     (define (show fmt n ch) ; internal function
       (format #t fmt (make-string n ch))
       (newline))

     (define (print-cake n)
       (show "   ~a   " n #\.)
       (show " .-~a-. " n #\|)
       (show " | ~a | " n #\space)
       (show "---~a---" n #\-))
     ;; --end my-cake.scm---

     ;; Be sure that the path of 'my-cake.scm' is in your current 
     ;; %load-path list. Use `use-modules' to get all `provide'd names 
     ;; from a module.
     (use-modules (my-cake)) ; the ' is for a local submodule
     (print-cake 3)
                                             ; (show "~a" 1 #\A) ; => error, `show' was not exported

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; 8. Classes and Objects
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; TODO
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; 9. Macros
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

     ;; Macros let you extend the syntax of the language

     ;; Let's add a while loop
     (define-syntax-rule (while condition body ...)
       (let loop ()
         (when condition
           body ...
           (loop))))

     (let ((i 0))
       (while (< i  10)
         (display i)
         (set! i (1+ i))))

     ;; Macros are hygienic, you cannot clobber existing variables!
     (define-syntax-rule (swap! x y) ; -! is idomatic for mutation
       (let ((tmp x))
         (set! x y)
         (set! y tmp)))

     (define tmp 1)
     (define a 2)
     (define b 3)
     (swap! a b)
     (format #t "tmp = ~a; a = ~a; b = ~a\n" tmp a b) ; tmp is unaffected

     ;; But they are still code transformations, for example:
     (define-syntax-rule (bad-while condition body ...)
       (when condition
         body ...
         (bad-while condition body ...)))
     ;; this macro is broken: it generates infinite code, if you try to use
     ;; it, the compiler will get in an infinite loop

   #+END_SRC

* 용어

** 테스트케이스 <<test_case>>
   CodeScroll 이 생성하는 함수별 테스트를 의미한다. 
** scheme 파일 <<scheme_file>>
   테스트 데이터를 생성하는 scheme 테스트 스크립트를 의미한다. 
** testsc 홈 <<testsc_home>>
** 테스트 변수 <<test_variable>>

* export 관련                                                     :noexport:
** no description 
   #+BEGIN_QUOTE
   ox-html 에서 html link 부분을 수정한다.  
   #+END_QUOTE
